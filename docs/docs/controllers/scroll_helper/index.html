<!DOCTYPE html><html lang="en"><head>
    <title>zKit: Scroll Helper (lib/controllers)</title>

    <meta content="text/html; charset=utf-8" http-equiv="content-type">
    <meta http-equiv="Content-Language" content="en-us">

    <meta name="description" content="zKit, a collection of framework-agnostic components for modern web.">
    <meta name="keywords" lang="en-us" content="web components,polymer,react,react.js,angular,angular.js,ember,ember.js,vue,vue.js,meteor,meteor.js,web app,pwa,progressive,web application,modern web,framework,javascript,library,content manager,component manager,web app,content authoring,web master,static site,spa,single page application,content loader,content include,material,material design lite,mdl">
    <meta name="author" content="G-Labs">

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,user-scalable=no">

    <!-- Add to homescreen for Chrome on Android -->
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="icon" sizes="192x192" href="../../../images/android-desktop.png">

    <!-- Add to homescreen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Material Design Lite">
    <link rel="apple-touch-icon-precomposed" href="../../../images/ios-desktop.png">

    <!-- Tile icon for Win8 (144x144 + tile color) -->
    <meta name="msapplication-TileImage" content="../../../images/touch/ms-touch-icon-144x144-precomposed.png">
    <meta name="msapplication-TileColor" content="#3372DF">

    <link rel="shortcut icon" href="../../../images/favicon.png">

    <meta name="google-site-verification" content="nkLa1C34WpSqkoDdFA0-rdb_tz412T9bAMZK7Uzu4y4">
    <!-- SEO: If your mobile URL is different from the desktop URL, add a canonical link to the desktop page https://developers.google.com/webmasters/smartphone-sites/feature-phones -->
    <!--
    <link rel="canonical" href="https://www.example.com/">
    -->

    <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="../../../css/flex-layout-attribute.min.css">

    <!-- zUIx library  -->
    <script src="../../../js/zuix/zuix.min.js"></script>
    <!--script src="../../../config.js"></script-->


<style>body {
    background-color: black;
    color: white;
    font-size: 16px;
    font-family: Helvetica, sans-serif;
    overflow-x: hidden;
}
footer {
    min-height: 96px;
    font-size: 120%;
    padding: 12px;
    background: #89675b;
    background: linear-gradient(#78909C 5%, #89675b);
}
p {
    font-family: serif;
    font-size: 180% !important;
    line-height: 160% !important;
    margin-top: 16px !important;
}
p code {
    font-size: 90%;
    opacity: 0.7;
    margin-left: 6px;
    margin-right: 6px;
}
h3 {
    opacity: 0.6;
}
h3 {
    font-weight: 900;
}
a,a:hover,a:visited {
    color:yellow !important;
}
li {
    font-family: serif;
    font-size: 170%;
    line-height: 160%;
    margin-bottom: 8px;
}
li small {
    opacity: 0.5;
}
pre {
    font-size:130%;
    line-height: 140%;
}
code.option {
    font-size: 80%;
    padding: 4px;
    border-radius: 6px;
    border: solid 1px rgba(0,200,0,0.25);
    background: rgba(255,255,255,0.15);
}

.logo {
    opacity: 0.5;
    color: white;
    font-size: 280% !important;
    vertical-align: middle;
    margin-right: 16px;
}

.max-width--1024 {
    max-width: 1024px;
}
.foremost {
    z-index: 10;
}
.watch {
    -webkit-transition: 150ms linear;
    -moz-transition: 150ms linear;
    -ms-transition: 150ms linear;
    -o-transition: 150ms linear;
    transition: 150ms linear;
}
.sh-parallax {
    position: absolute;
    max-width: 1024px;
    transform: translateY(0);
}
.sh-title {
    font-family: serif;
    -webkit-transform-origin: top center;
    -moz-transform-origin: top center;
    -ms-transform-origin: top center;
    -o-transform-origin: top center;
    transform-origin: top center;
}
.arrow-down {
    cursor: pointer;
    -webkit-transition: 0.1s ease-in-out;
    -moz-transition: 0.1s ease-in-out;
    -ms-transition: 0.1s ease-in-out;
    -o-transition: 0.1s ease-in-out;
    transition: 0.1s ease-in-out;
}
.arrow-down i {
    font-size:500% !important;
    opacity: 0.5;
    z-index:10;
}

.intro-page {
    width: 100%;
    min-height: 100vh;
    z-index:10;
    background: #89675b;
    background: linear-gradient(#89675b 30%, #78909C);
    padding: 16px 16px 72px;
}

.features {
    padding-left: 8px;
    padding-right: 8px;
    margin-top: 48px;
    margin-bottom: 48px;
}
.features li {
    list-style: none;
    padding-top: 8px;
    padding-bottom: 8px;
    font-family: Helvetica, sans-serif;
}
.features li code {
    color: #ffff66;
}
.features li strong {
    opacity: 0.75;
}

.content {
    margin-top: 1px;
    padding: 72px 16px 72px;
}

.hidden {
    display: none;
}

[data-ui-field="header-menu"] {
    width: 100%;
    height: 64px;
    position: fixed;
    top:0; left: 0;
    box-shadow: 0 6px 10px 6px rgba(0,0,0,0.15);
    z-index: 100;
    color: rgba(255,255,255,0.75);
}
[data-ui-field="header-menu"] .title {
    font-size:160%;
    font-weight: 700;
    margin-left: 24px;
}
[data-ui-field="header-menu"] button {
    margin-right: 20px;
}

.sh-sky-background {
    max-width: '1024px';
    min-height: 175vh;
    background-color: #5ec8d5;
    background: linear-gradient(to bottom, rgb(155, 190, 209) 0%, rgb(247, 247, 246) 50%, rgb(250, 202, 158) 70%, rgb(246, 155, 108) 85%, darkblue 100%);
}

.sh-sky-background .arrow-down {
    margin-top: 50vh;
    z-index: 10;
}


/*
|| CapGuy Animation
|| (c) Kerstin Mueller
|| https://www.codeandweb.com/blog/2014/11/05/animate-sprites-in-css-with-texturepacker
*/
.sh--capguy {
    position: absolute;
    width: 184px; height: 325px; /* <--  size of a single frame*/
    background-image: url('../../../images/capguy-walk.png'); /* <-- url to spritesheet*/
    -webkit-animation: sh--capguy-walk 1s steps(8) infinite;
    -moz-animation: sh--capguy-walk 1s steps(8) infinite;
    -o-animation: sh--capguy-walk 1s steps(8) infinite;
    animation: sh--capguy-walk 1s steps(8) infinite; /* <-- animation parameters, see below*/
    z-index: 20;
    opacity: 0;
}
.sh--capguy h3 {
    position: absolute;
    top: -80px;
    -webkit-text-stroke: 1px black;
    color: lime;
    text-shadow:
            2px 2px 0 #000,
            -1px -1px 0 #fff,
            1px -1px 0 #000,
            -1px 1px 0 #000,
            1px 1px 0 #000;
}
.sh--capguy .back {
    moz-transform: scaleX(-1);
    -o-transform: scaleX(-1);
    -webkit-transform: scaleX(-1);
    transform: scaleX(-1);
    filter: 'FlipH';
    -ms-filter: 'FlipH';
}
@-webkit-keyframes sh--capguy-walk {
    from { background-position: 0; }
    to { background-position: -1472px; }  /* <-- width of spritesheet*/
}

@-moz-keyframes sh--capguy-walk {
    from { background-position: 0; }
    to { background-position: -1472px; } /* <-- width of spritesheet*/
}

@-o-keyframes sh--capguy-walk {
    from { background-position: 0; }
    to { background-position: -1472px; } /* <-- width of spritesheet*/
}

@keyframes sh--capguy-walk {
    from { background-position: 0; }
    to { background-position: -1472px; } /* <-- width of spritesheet*/
}
</style>
<script>const pauseCapGuy = function(el) {
    el.css('animation-play-state', 'paused');
};
let scrollHelper;
let guyAnimationTimeout;
let guyLastPosition = 0;
var scroll_opts = {
    ready: function(ctx) {
        scrollHelper = this;
        this.on('scroll:change', function(e, data) {
            switch (data.event) {
                case 'hit-top':
                    // TODO: reached top of the page
                    break;
                case 'scroll':
                    // scrolling...
                    if (zuix.field('btn-go-bottom').hasClass('mdl-button--disabled')) {
                        zuix.field('btn-go-bottom').removeClass('mdl-button--disabled');
                    }
                    break;
                case 'hit-bottom':
                    // reached end of the page
                    zuix.field('btn-go-bottom').addClass('mdl-button--disabled');
                    showMenu();
                    break;
            }
        }).watch('.watch', function(el, data) {
            if (data.event === 'scroll' || data.event === 'off-scroll') {
                el = zuix.$(el);
                playStoryBoard(el, data);
            }
        });
        zuix.field('arrow-down').on('click', function() {
            scrollToIntro(1250);
        });
        zuix.field('arrow-docs').on('click', function() {
            scrollHelper.scrollTo(zuix.$.find('.sh-usage-anchor'), 500);
            showMenu();
        });
    }
};

let scrollDirection = 1;
function playStoryBoard(el, data) {
    let dy = data.frame.dy;
    if (el.hasClass('sh--capguy')) {
        // CapGuy walking animation
        const position = el.position();
        const availableWidth = scrollHelper.info().viewport.width;
        dy = (1 - dy);
        if (dy <= 1.5) {
            let offsetX = (availableWidth*1.5*(dy - 0.2));
            let offsetY = zuix.field('landscape').position().rect.bottom-position.y+50;
            offsetY -= el.get().clientHeight;
            let transform = 'translate(' + offsetX + 'px,' + offsetY + 'px)';
            let changedDirection = false;
            if (guyLastPosition > dy) {
                changedDirection = scrollDirection > 0;
                scrollDirection = -1;
                transform = 'scaleX(-1) translate(' + (-offsetX) + 'px,' + offsetY + 'px)';
            } else {
                changedDirection = scrollDirection < 0;
                scrollDirection = 1;
            }
            guyLastPosition = dy;
            if (changedDirection) {
                el.css('transition', 'none');
            } else el.css('transition', '');
            el.css('transform', transform);
            el.css('animation-play-state', 'initial');
            if (guyAnimationTimeout != null) {
                clearTimeout(guyAnimationTimeout);
            }
            guyAnimationTimeout = setTimeout(function() {
                pauseCapGuy(el);
            }, 200);
        }
        fadeInOut(el, data);
    } else if (el.hasClass('sh-parallax')) {
        // Castle Hills parallax animation
        if (dy < 0) return;
        const dt = parseFloat(el.attr('data-translate'));
        let translate = -(dy * dt * document.documentElement.offsetHeight);
        el.css('transform-origin', 'center bottom');
        el.css('transform', 'translateY(' + translate + 'px)');
        // TODO: blur effect is likely to cause scroll jumps/glitches
        // blur(el, (dy - dt), -0.25, 0.25);
        fadeInOut(el, data, 0, 0.15);
    } else if (el.hasClass('sh-title')) {
        if (dy < 1.2 && dy > 0.4) {
            const scale = dy / 0.4;
            el.css('transform', 'scale('+scale+')');
        }
        fadeInOut(el, data);
    } else if (el.hasClass('sh-usage-anchor')) {
        // show/hide header-menu when below/above the 'Usage' title
        if (dy <= 0) {
            if (scrollHelper.info().shift.y >= 0) {
                showMenu();
            } else {
                hideMenu();
            }
        } else {
            hideMenu();
        }
    } else {
        // Default "watchable" animation:
        //     ---> Fade-In enter / Fade-Out exit
        fadeInOut(el, data);
    }
}
/*
function blur(el, dy, startOffset, endOffset) {
    if (dy >= startOffset && dy <= endOffset) {
        const radius = Math.round((endOffset - dy) * 100 / 5);
        el.css('-webkit-filter', 'blur(' + radius + 'px)');
        el.css('filter', 'blur(' + radius + 'px)');
    } else {
        el.css('-webkit-filter', null);
        el.css('filter', null);
    }
}
*/
function fadeInOut(el, data, startOffset, endOffset) {
    if (startOffset == null) {
        startOffset = 0.2;
    }
    if (endOffset == null) {
        endOffset = 0.2;
    }
    if (data.frame.dy < startOffset) {
        el.css('opacity', data.frame.dy / startOffset);
    } else if (data.frame.dx < startOffset) {
        el.css('opacity', data.frame.dx / startOffset);
    } else if (data.frame.dy > 1-endOffset) {
        el.css('opacity', (1 - data.frame.dy) / endOffset);
    } else if (data.frame.dx > 1-endOffset) {
        el.css('opacity', (1 - data.frame.dx) / endOffset);
    } else if (parseFloat(el.css('opacity')) !== 1) {
        el.css('opacity', 1);
    }
}

function showMenu() {
    const menu = zuix.field('header-menu');
    if (menu.hasClass('hidden')) {
        menu.removeClass('hidden')
            .animateCss('fadeInDown').show();
    }
}

function hideMenu() {
    const menu = zuix.field('header-menu');
    if (!menu.hasClass('hidden') && !menu.hasClass('animated')) {
        menu.animateCss('fadeOutUp', function() {
            this.addClass('hidden');
        });
    }
}

function scrollToIntro(duration) {
    const viewport = scrollHelper.info().viewport;
    scrollHelper.scrollTo(viewport.height*1.75, duration);
}

function scrollNext() {
    let nextElement;
    const vp = scrollHelper.info().viewport;
    zuix.$.find('h2').each(function(i, el) {
        if (this.position().y > vp.height && (nextElement == null || nextElement.position().y > this.position().y)) {
            nextElement = this;
        }
    });
    if (nextElement != null) {
        scrollHelper.scrollTo(nextElement.position().y-vp.y-80, 500);
    } else {
        scrollHelper.scrollEnd(500);
    }
}

function scrollPrev() {
    let prevElement;
    const vp = scrollHelper.info().viewport;
    zuix.$.find('h2').each(function(i, el) {
        if (!this.hasClass('no-index') && this.position().y < 0 && (prevElement == null || prevElement.position().y < this.position().y)) {
            prevElement = this;
        }
    });
    if (prevElement != null) {
        scrollHelper.scrollTo(prevElement.position().y-vp.y-80, 500);
    } else {
        scrollToIntro(500);
    }
}</script>

    <style>[data-ui-view] { display: none; }</style>
</head>

<body layout="column top-stretch" data-ui-load="@lib/controllers/scroll_helper" data-ui-context="scroll-helper" data-ui-options="scroll_opts">


    <!-- Parallax Header -->
    <div data-ui-field="parallax-header" self="center" layout="column center-center" class="sh-sky-background max-width--1024">

        <div data-ui-field="arrow-down" class="arrow-down">
            <i class="material-icons animated fadeInDown infinite">arrow_downward</i>
        </div>

        <!--"Castle Hills" graphics &copy; craftpix.net -->
        <div self="bottom" layout="column center-center">
            <!--
            <img class="watch sh-parallax" data-translate="0.2" src="../../../images/parallax/layer07_Sky.png">
            -->
            <img class="watch sh-parallax" data-translate="0.5" src="../../../images/parallax/layer06_Rocks.png">
            <img class="watch sh-parallax" data-translate="0.35" src="../../../images/parallax/layer05_Hills.png">
            <img class="watch sh-parallax" data-translate="0.2" src="../../../images/parallax/layer04_Clouds.png">
            <img class="watch sh-parallax" data-translate="0.1" src="../../../images/parallax/layer03_Hills_Castle.png">
            <img class="watch sh-parallax" data-translate="0.05" src="../../../images/parallax/layer02_Trees_rocks.png">
            <img class="max-width--1024 foremost" data-translate="0.2" src="../../../images/parallax/layer01_Ground.png" data-ui-field="landscape">
        </div>

    </div>


    <!-- The guy -->
    <div class="watch sh--capguy"><!--<h3>Hello World!</h3> --></div>


    <!-- Introduction -->
    <div class="intro-page" layout="column center-center">

        <h1 class="watch sh-title mdl-color-text--green-200">Scroll Helper</h1>

        <div self="size-medium" layout="columns top-stretch">
            <!--
            <h3 class="watch no-index" align="center">
                solution to web page scroll handling
            </h3>
            -->
            <ul class="features">
                <li class="watch">
                    <code>scroll:change</code> <strong>event</strong>
                    to handle motion, direction update and boundary hit
                </li>
                <li class="watch">
                    <code>watch</code> <strong>method</strong> to get
                    notified as DOM elements move inside or enter/exit the viewport
                </li>
                <li class="watch">
                    <code>scrollTo</code> <strong>method</strong> with
                    smooth scrolling facility
                </li>
            </ul>
        </div>

        <div data-ui-field="arrow-docs" class="watch arrow-down">
            <i class="material-icons">arrow_downward</i>
        </div>

    </div>


    <!-- Content -->
    <a class="watch sh-usage-anchor"></a>
    <div class="content mdl-color--blue-grey-400" layout="column top-center">

        <div self="size-large center" layout="columns top-stretch">

            <h2>Usage</h2>
<h3>1. Include zUIx library</h3>
<p>Add the following line, preferably inside the <code>head</code> section of the <code>HTML</code> document:</p>

<pre><code class="html">&lt;script src="//genielabs.github.io/zuix/js/zuix.min.js"&gt;&lt;/script&gt;</code></pre>


            <h3>2. Load the scroll helper</h3>
            <p>
                Add the <code>data-ui-load</code> attribute to the element implementing the scroll (usually <code>body</code>
                or a <code>div</code> element)
            </p>

<pre><code class="html">&lt;body data-ui-load="@lib/controllers/scroll_helper"
      data-ui-context="scroll-helper"&gt;
  <!-- scrollable content -->
&lt;/body&gt;</code></pre>




            <h2>Option attributes</h2>
            <ul>
                <li>
                    <code class="option">data-ui-load="@lib/controllers/scroll_helper"</code>
                    <small>constructor</small><br>
                    load the <code>scroll_helper</code> controller on the element.
                </li>
                <li>
                    <code class="option">data-ui-context</code>
                    <small>optional</small><br>
                    identifier name to be used to reference this instance from JavaScript.
                </li>
            </ul>




            <h2>Scripting</h2>
            <h3>Get a reference to the scroll helper object</h3>

            <p>Before component is loaded</p>

<pre><code class="js">var scrollHelper; // it will be == null until component is loaded
zuix.context('scroll-helper', function() {
  // component loaded
  scrollHelper = this;
});</code></pre>

            <p>or at any time after component is loaded</p>

<pre><code class="js">var scrollHelper = zuix.context('scroll-helper');</code></pre>


            <h3>Listen to events</h3>

<pre><code class="js">scrollHelper.on('scroll:change', function(e, data) {
  switch (data.event) {
    case 'hit-top':
      // reached top of page
      break;
    case 'scroll':
      if (data.info.shift.y &lt; 0) {
        // scrolling up
      } else if (data.info.shift.y &gt; 0) {
        // scrolling down
      }
      // for all fields of the data.info
      // object see next paragraph
      break;
    case 'hit-bottom':
      // reached end of page
      break;
  }
});</code></pre>

            <h3>Get scroll information</h3>

<pre><code class="js">// get the scroll info object
const info = scrollHelper.info();

info -&gt; {
  // last event timestamp
  timestamp: 1524263175438,
  // movement since previous event
  shift: {
    x: 0,
    y: -3
  },
  // total scroll area size
  size: {
    width: 1280,
    height: 5281
  },
  // visible area size and position
  viewport: {
    x: 0,
    y: -3313,
    width: 1280,
    height: 720
  }
}</code></pre>


            <h2>Watching DOM elements</h2>
            <p>
                The <code>watch</code> method takes one argument that can be either an element object or a valid
                DOM query selector expression.
            </p>

<pre><code class="js">// watch elements having the 'watchable' class
scrollHelper.watch('.watchable', function(el, data) {
    switch (data.event) {
        case 'enter':
            // element entered the visible area
            break;
        case 'exit':
            // element out of the visible area
            break;
        case 'scroll':
            // element is being scrolled in the visible area
            break;
        case 'off-scroll':
            // element is being scrolled out of the visible area
            break;
    }
});</code></pre>

            <p>
                The <code>data</code> object passed to the watch callback is described below
            </p>

<pre><code class="js">data = {
    // event: 'enter' | 'exit' | 'scroll' | 'off-scroll'
    event,
    // element position, status, rect and frame
    x,       // float
    y,       // float
    visible, // boolean
    rect: {  // DOMRect
        x,
        y,
        height,
        width,
        left,
        right,
        top,
        bottom
    },
    frame: { // relative center position
        dx,
        dy,
    }
}</code></pre>

            <p>
                The <code>frame</code> object represents the position of the center of the element
                relative to the viewport size. Specifically, <code>dx</code> and <code>dy</code> are
                float numbers that have values between <code>0</code> and <code>1</code> when the element
                is inside the viewport. So when the element is at the center of the viewport, <code>dx</code>
                and <code>dy</code> will have a value of <code>0.5</code>.
                Otherwise it will be less than <code>0</code> if the element is above the viewport top or
                lastly greater than <code>1</code> when the element is below the viewport bottom.
                This value can be used to create responsive and synchronized scroll animations based on
                current viewport offset and elements position.
            </p>




            <h3>Other methods</h3>

<pre><code class="js">// scroll to the start of page
scrollHelper.scrollStart( [duration_ms] );
// scroll to the end of page
scrollHelper.scrollEnd( [duration_ms] );
// scroll to element or offset
scrollHelper.scrollTo( element | offset_px );
</code></pre>



            <h2>Source code</h2>
            <p>
                Source code is available in the <code>lib/controllers</code> folder of <a href="//github.com/genielabs/zkit">zKit</a> repository.
            </p>
            <div self="size-large">
                <ul class="list">
                    <li><a href="//github.com/genielabs/zkit/blob/master/source/lib/controllers/scroll_helper.js">scroll_helper.js</a></li>
                </ul>
            </div>

        </div>

    </div>


    <div data-ui-field="header-menu" class="hidden mdl-color--green-400" layout="row center-left">
        <div self="size-1of2" class="title">Scroll Helper</div>
        <div self="size-1of2" align="right">

            <a href="../../../"><i class="material-icons logo">extension</i></a>

            <button data-ui-field="btn-go-top" class="mdl-button mdl-js-button mdl-button--fab mdl-button--mini-fab mdl-js-ripple-effect mdl-color--green-200" onclick="scrollPrev()">
                <i class="material-icons">arrow_upward</i>
            </button>
            <button data-ui-field="btn-go-bottom" class="mdl-button mdl-js-button mdl-button--fab mdl-button--mini-fab mdl-js-ripple-effect mdl-color--green-200" onclick="scrollNext()">
                <i class="material-icons">arrow_downward</i>
            </button>

        </div>
    </div>


    <footer layout="column center-center">
    <div layout="rows center-justify" class="footer-block">
        <div self="size-x1 center-right"><a href="../../../"><strong>zKit</strong></a> <small>components for modern web</small></div>
        <div self="center-right">made with <strong><a href="http://zuix.it">zUIx</a></strong></div>
    </div>
</footer>


    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async="" src="//www.googletagmanager.com/gtag/js?id=UA-116384214-1"></script>
<script>
    // Google Analytics
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-116384214-1');
</script>

<!-- MDL -->
<link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.indigo-pink.min.css">
<script defer="" src="https://code.getmdl.io/1.3.0/material.min.js"></script>


<!-- Common JS scripts -->
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.12.0/build/styles/androidstudio.min.css">
<script>
    // Escape HTML in 'code' blocks
    document.querySelectorAll("code").forEach(function(element) {
        element.innerHTML = element.innerHTML/*.replace(/&/g, "&amp;")*/.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
    });
    // AnimateCSS
    zuix.using('component', '@lib/extensions/animate_css');
    // Code highlighting
    zuix.using('script', '//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.12.0/build/highlight.min.js', function () {
        zuix.$('pre code').each(function(i, block) {
            hljs.highlightBlock(block);
        });
    });
</script>


<!-- zUIx inline resource resourceBundle -->
<!--{[@lib/components/media_browser]}-->
<div data-ui-view="@lib/components/media_browser">
<div data-ui-field="container" class="container">

    <div data-ui-load="@lib/controllers/view_pager" data-o-paging="true" data-ui-field="media" class="media-list hidden"><!-- no-view --></div>

    <div data-ui-field="controls">

        <div data-ui-load="@lib/controllers/view_pager" data-ui-field="carousel" layout="row center-left"><!-- no-view --></div>

    </div>

    <div data-ui-field="nav-close">
        <svg fill="#FFFFFF" height="48" width="48" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path>
            <path d="M0 0h24v24H0z" fill="none"></path>
        </svg>
    </div>
    <div data-ui-field="nav-prev">
        <svg fill="white" height="48" width="48" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path>
            <path d="M0 0h24v24H0z" fill="none"></path>
        </svg>
    </div>
    <div data-ui-field="nav-next">
        <svg fill="white" height="48" width="48" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"></path>
            <path d="M0 0h24v24H0z" fill="none"></path>
        </svg>
    </div>

    <div data-ui-field="progress-container">
        <div data-ui-field="load-progress"></div>
    </div>

</div>
<script></script>

</div>
<!--{[@lib/components/menu_overlay]}-->
<div data-ui-view="@lib/components/menu_overlay">
<!-- FAB menu overlay -->
<div data-ui-field="menu_overlay">
    <div data-ui-field="items_wrapper"></div>
</div>

<!-- Colored FAB menu button -->
<div data-ui-field="menu_button" class="menu-button">
    <div class="circle-button">
        <svg height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
            <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path>
            <path d="M0 0h24v24H0z" fill="none"></path>
        </svg>
    </div>
</div>
<div data-ui-field="menu_button_close" class="menu-button">
    <div class="circle-button">
        <svg height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path>
            <path d="M0 0h24v24H0z" fill="none"></path>
        </svg>
    </div>
</div>

</div>
    <script>zuix.bundle([
  {
    "componentId": "@lib/components/media_browser",
    "controller": "'use strict';\n\nzuix.controller(function(cp) {\n    let currentPage = 0;\n    let itemsListVisible = false;\n    // view_pager views\n    let fullView;\n    let listView;\n    /** @typedef {ZxQuery} */\n    let imageList;\n    /** @typedef {ZxQuery} */\n    let buttonNext;\n    /** @typedef {ZxQuery} */\n    let buttonPrev;\n    /** @typedef {ZxQuery} */\n    let buttonClose;\n\n    let youtubeApiCallbacks = [];\n    let youtubeApiReady = false;\n\n    cp.create = function() {\n        // export public component methods\n        cp.expose('open', openBrowser)\n            .expose('close', closeBrowser)\n            // .expose('items', setItems)\n            .expose('youtubeApi', function(callback) {\n                if (youtubeApiReady) callback();\n                else youtubeApiCallbacks.push(callback);\n            }).expose('current', setCurrent)\n            .expose('showControls', showControls)\n            .expose('hideControls', hideControls)\n            .expose('toggleControls', toggleControls)\n            .expose('showList', showList)\n            .expose('hideList', hideList);\n\n        cp.view().css({\n            'position': 'fixed',\n            'left': 0,\n            'right': 0,\n            'top': 0,\n            'bottom': 0,\n            'z-index': 20\n        }).hide();\n\n        // load Animate CSS extension\n        zuix.using('component', '@lib/extensions/animate_css', function() {\n            showControls();\n        });\n\n        // add youtube API\n        // This code loads the IFrame Player API code asynchronously.\n        window.onYouTubeIframeAPIReady = function() {\n            zuix.$.each(youtubeApiCallbacks, function() {\n                this();\n            });\n            youtubeApiCallbacks = [];\n            youtubeApiReady = true;\n        };\n        const tag = document.createElement('script');\n        tag.src = 'https://www.youtube.com/iframe_api';\n        const firstScriptTag = cp.view().find('script').get();\n        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);\n\n        // Main ViewPager\n        zuix.context(cp.field('media'), function() {\n            fullView = this\n                .on('gesture:tap', toggleControls)\n                .on('page:change', function(e, page) {\n                    listView.page(page.in);\n                    cp.trigger('page:change', page);\n                });\n            buttonPrev = cp.field('nav-prev').on('click', function() {\n                fullView.prev();\n            });\n            buttonNext = cp.field('nav-next').on('click', function() {\n                fullView.next();\n            });\n            buttonClose = cp.field('nav-close').on('click', closeBrowser);\n            // setup media list with thumbnails and full screen items with temporary background preview\n            imageList = cp.field('media')\n                .children().each(function(i, el) {\n                    let preview = this.find('[data-ui-field=\"preview\"]');\n                    if (preview.length() > 0) {\n                        this.css('background', 'url(\"'+preview.find('img').attr('src')+'\") scroll no-repeat center/contain');\n                        cp.field('carousel')\n                            .append(preview.detach().get());\n                    } else {\n                        // TODO: add a button or something if preview thumbnail not specified\n                        cp.field('carousel')\n                            .append(document.createElement('div'));\n                    }\n                });\n            cp.field('media').children().each(function(i, el) {\n                let type = this.attr('data-type');\n                if (type == null) type = 'image'; // default type\n                this.attr('data-ui-load', cp.context.componentId+'/'+type);\n                if (type !== 'video') {\n                    this.attr('data-ui-lazyload', true);\n                }\n                this.attr('data-index', i);\n                zuix.context(el, function() {\n                    this.host(cp.view());\n                });\n            });\n        });\n        // Carousel ViewPager\n        zuix.context(cp.field('carousel'), function() {\n            listView = this;\n            listView\n                .on('page:change', pageChanged)\n                .on('page:tap', function(e, page) {\n                    fullView.page(page);\n                });\n        });\n        // Keyboard navigation handling\n        cp.view().attr('tabindex', 0)\n            .on('blur', function() {\n                this.get().focus();\n            }).get().focus();\n        document.onkeydown = function(e) {\n            switch (e.keyCode) {\n                case 27: // esc\n                    closeBrowser();\n                    break;\n                case 32: // space\n                    toggleControls();\n                    break;\n                case 37: // left\n                    fullView.prev();\n                    break;\n                case 38: // up\n                    showControls();\n                    break;\n                case 39: // right\n                    fullView.next();\n                    break;\n                case 40: // down\n                    hideControls();\n                    break;\n            }\n        };\n    };\n\n    function pageChanged(e, page) {\n        currentPage = page.in;\n        listView.get(currentPage)\n            .attr('data-ui-lazyload', false)\n            .children().eq(0).addClass('page-active');\n        if (page.out !== -1) {\n            listView.get(page.out).children().eq(0).removeClass('page-active');\n        }\n        updateButtons();\n        // TODO: not yet sure why is this timeout required to make it work\n        setTimeout(function() {\n            zuix.componentize(cp.field('media'), listView.get(currentPage));\n        }, 200);\n    }\n\n    function setCurrent(current) {\n        return fullView.page(current);\n    }\n\n    function openBrowser() {\n        // hide navigation buttons\n        buttonClose.animateCss('rotateIn', {duration: '0.75s'});\n        buttonNext.hide();\n        buttonPrev.hide();\n        // show the media browser and update buttons\n        cp.field('media').removeClass('hidden');\n        cp.view().animateCss('zoomIn', {duration: '0.5s'}, function() {\n            // refresh ViewPager\n            fullView.refresh();\n            listView.refresh();\n            updateButtons();\n            // TODO: not yet sure why is this timeout required to make it work\n            // force load of current item\n            setTimeout(function() {\n                // make pages visible (this should run once though)\n                cp.field('media').children().each(function() {\n                    this.css('visibility', 'visible');\n                });\n                zuix.componentize(cp.field('media'), listView.get(currentPage));\n            }, 200);\n            this.trigger('open');\n        }).show();\n        return cp.context;\n    }\n\n    function closeBrowser() {\n        buttonClose.animateCss('rotateOut', {duration: '0.5s'});\n        cp.view().animateCss('zoomOut', {duration: '0.5s', delay: '0.15s'}, function() {\n            this.hide();\n        }).trigger('close');\n        return cp.context;\n    }\n\n    function updateButtons() {\n        if (imageList == null) return;\n        // show navigation buttons as needed\n        if (currentPage < imageList.length() - 1) {\n            if (buttonNext.display() === 'none') {\n                buttonNext.animateCss('fadeInRight').show();\n            }\n        } else {\n            if (buttonNext.display() !== 'none') {\n                buttonNext.animateCss('fadeOutRight', function() {\n                    this.hide();\n                });\n            }\n        }\n        if (currentPage > 0 && imageList.length() > 1) {\n            if (buttonPrev.display() === 'none') {\n                buttonPrev.animateCss('fadeInLeft').show();\n            }\n        } else {\n            if (buttonPrev.display() !== 'none') {\n                buttonPrev.animateCss('fadeOutLeft', function() {\n                    this.hide();\n                });\n            }\n        }\n        if (buttonClose.display() === 'none') {\n            buttonClose.animateCss('fadeInDown', {duration: '0.35s', delay: '0.5s'}).show();\n        }\n    }\n\n    function toggleControls(e, tp) {\n        if (tp == null || !zuix.$(tp.event.target).hasClass('capture-touch')) {\n            if (cp.field('controls').display() !== 'none') {\n                hideControls();\n            } else {\n                showControls();\n            }\n            if (tp != null) tp.cancel();\n        }\n    }\n\n    function showList() {\n        if (!itemsListVisible) {\n            itemsListVisible = true;\n            cp.field('controls').animateCss('fadeInUp').show();\n            if (listView != null && fullView != null) {\n                listView.page(fullView.page());\n            }\n            cp.trigger('controls:show');\n        }\n    }\n    function hideList() {\n        if (itemsListVisible) {\n            itemsListVisible = false;\n            cp.field('controls').animateCss('fadeOutDown', function() {\n                this.hide();\n            });\n        }\n    }\n\n    function hideControls() {\n        hideList();\n        if (buttonPrev.display() !== 'none') {\n            buttonPrev.animateCss('fadeOutLeft', function() {\n                this.hide();\n            });\n        }\n        if (buttonNext.display() !== 'none') {\n            buttonNext.animateCss('fadeOutRight', function() {\n                this.hide();\n            });\n        }\n        if (buttonClose.display() !== 'none') {\n            buttonClose.animateCss('fadeOutUp', {duration: '0.35s'}, function() {\n                this.hide();\n            });\n        }\n        cp.trigger('controls:hide');\n    }\n    function showControls() {\n        showList();\n        updateButtons();\n    }\n});\n",
    "css": ". {\n    -webkit-touch-callout: none; /* iOS Safari */\n    -webkit-user-select: none; /* Safari */\n    -khtml-user-select: none; /* Konqueror HTML */\n    -moz-user-select: none; /* Firefox */\n    -ms-user-select: none; /* Internet Explorer/Edge */\n    user-select: none; /* Non-prefixed version, currently\n                                  supported by Chrome and Opera */\n    overflow: hidden;\n}\n\n.container {\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    z-index: 20;\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -moz-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-flex-align: stretch;\n    -ms-flex-align: stretch;\n    -webkit-align-items: stretch;\n    align-items: stretch;\n    justify-content: center;\n    background: black;\n}\n\nsvg {\n    vertical-align: middle;\n}\n\n[data-ui-field=\"media\"] article {\n    visibility: hidden;\n    width: 100vw;\n    height: 100vh;\n}\n\n[data-ui-field=\"media\"] article:not([data-ui-loaded]) > * {\n    display: none;\n}\n\n[data-ui-field=\"controls\"] {\n    position: fixed;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    height: 140px;\n    z-index: 10;\n    padding-left: 10px;\n    padding-right: 10px;\n    background-color: rgba(255,255,255,0.25);\n    /*background-color: rgba(0,0,0,0.5);*/\n}\n\n[data-ui-field=\"nav-prev\"] {\n    border: solid 2px white;\n    border-radius: 48px;\n    margin: 6px;\n    position: absolute;\n    left: 12px;\n    bottom: 45%;\n    z-index: 10;\n    background-color: rgba(1,1,1,0.5);\n    opacity: 0.5;\n}\n[data-ui-field=\"nav-next\"] {\n    border: solid 2px white;\n    border-radius: 48px;\n    margin: 6px;\n    position: absolute;\n    right: 12px;\n    bottom: 45%;\n    z-index: 10;\n    background-color: rgba(1,1,1,0.5);\n    opacity: 0.5;\n}\n[data-ui-field=\"nav-close\"] {\n    position: absolute;\n    right: 16px;\n    top: 16px;\n    z-index: 10;\n    opacity: 0.5;\n}\n[data-ui-field=\"progress-container\"] {\n    position: absolute;\n    top: 32px;\n    z-index: 10;\n    width: 128px;\n    color: white;\n    font-weight: 700;\n    font-size: 32px;\n    text-align: center;\n    text-shadow:\n        -2px -2px 0 darkblue,\n        2px -2px 0 darkblue,\n        -2px 2px 0 darkblue,\n        2px 2px 0 darkblue;\n}\n\ni {\n    cursor: pointer;\n}\n\n.hidden {\n    display: none;\n}\n\n.media-list {\n    width: 100%;\n    height: 100%;\n}\n\n.above-controls {\n    margin-bottom: 80px;\n}\n\n.rounded-border {\n    border-radius: 5px;\n    -webkit-transform: scale(0.9);\n    -moz-transform: scale(0.9);\n    -ms-transform: scale(0.9);\n    -o-transform: scale(0.9);\n    transform: scale(0.9);\n}\n\n.page-active {\n    border: solid 1px rgba(255,255,255,0.9) !important;\n    -webkit-transform: scale(1.125);\n    -moz-transform: scale(1.125);\n    -ms-transform: scale(1.125);\n    -o-transform: scale(1.125);\n    transform: scale(1.125);\n}\n\n[data-ui-field=\"carousel\"] {\n    overflow: visible !important;\n    height: 100%;\n}\n\n[data-ui-field=\"preview\"] {\n    padding: 10px;\n    max-width: 100%;\n    max-height: 100%;\n}\n[data-ui-field=\"preview\"] img {\n    overflow: hidden;\n    height: 120px;\n    max-height: 120px;\n    border-radius: 8px;\n    border: solid 1px rgba(0,0,0, 0.5);\n    box-shadow: -4px 4px 16px 3px rgba(0,0,0,0.5);\n    transition: 0.1s ease-in;\n}\n\n\n@media only screen and (max-width: 820px) {\n    [data-ui-field=\"controls\"] {\n        height: 104px;\n    }\n    [data-ui-field=\"preview\"] img {\n        max-height: 80px;\n    }\n    [data-ui-field=\"nav-prev\"] {\n        left: 6px;\n    }\n    [data-ui-field=\"nav-next\"] {\n        right: 6px;\n    }\n    [data-ui-field=\"nav-close\"] {\n        right: 12px;\n        top: 12px;\n    }\n}"
  },
  {
    "componentId": "@lib/controllers/view_pager",
    "controller": "/**\n * zUIx - ViewPager Component\n *\n * @version 1.0.2 (2018-06-25)\n * @author Gene\n *\n * @version 1.0.1 (2018-02-12)\n * @author Gene\n *\n */\n\n'use strict';\n\nzuix.controller(function(cp) {\n    const DEFAULT_PAGE_TRANSITION = {duration: 0.3, easing: 'ease'};\n    const LAYOUT_HORIZONTAL = 'horizontal';\n    const LAYOUT_VERTICAL = 'vertical';\n    const SLIDE_DIRECTION_FORWARD = 1;\n    const SLIDE_DIRECTION_BACKWARD = -1;\n    // state vars\n    let currentPage = -1;\n    let oldPage = 0;\n    let slideTimeout = null;\n    let slideIntervalMs = 3000;\n    let slideDirection = SLIDE_DIRECTION_FORWARD;\n    let updateLayoutTimeout = null;\n    let inputCaptured = false;\n    // options\n    let layoutType = LAYOUT_HORIZONTAL;\n    let enableAutoSlide = false;\n    let enablePaging = false;\n    let holdTouch = false;\n    let isDragging = false;\n    let wasVisible = false;\n    let componentizeInterval = null;\n    let componentizeTimeout = null;\n    /** @typedef {ZxQuery} */\n    let pageList = null;\n    // Create an observer instance to watch for child add/remove\n    const domObserver = new MutationObserver(function(a, b) {\n        // TODO: this does not seem to be working, fix it! =/\n        // update child list and re-layout\n        pageList = cp.view().children();\n        updateLayout();\n    });\n\n    cp.init = function() {\n        let options = cp.options();\n        let view = cp.view();\n        options.html = false;\n        options.css = false;\n        enablePaging = (options.enablePaging === true || (view.attr('data-o-paging') === 'true'));\n        enableAutoSlide = (options.autoSlide === true || (view.attr('data-o-slide') === 'true'));\n        holdTouch = (options.holdTouch === true || (view.attr('data-o-hold') === 'true'));\n        if (options.verticalLayout === true || (view.attr('data-o-layout') === LAYOUT_VERTICAL)) {\n            layoutType = LAYOUT_VERTICAL;\n        }\n        if (options.slideInterval != null) {\n            slideIntervalMs = options.slideInterval;\n        } else if (view.attr('data-o-slide-interval') != null) {\n            slideIntervalMs = parseInt(view.attr('data-o-slide-interval'));\n        }\n    };\n\n    cp.create = function() {\n        const view = cp.view();\n        // enable absolute positioning for items in this view\n       view.css({\n            'position': 'relative',\n            'overflow': 'hidden'\n        });\n        // get child items (pages)\n        pageList = view.children();\n        // loading of images could change elements size, so layout update might be required\n        view.find('img').each(function(i, el) {\n            this.one('load', updateLayout);\n        });\n        // re-arrange view on layout changes\n        zuix.$(window).on('orientationchange', function() {\n            updateLayout();\n        });\n        // Options for the observer (which mutations to observe)\n        const config = {attributes: false, childList: true, subtree: false};\n        // DOM mutation observer\n        domObserver.observe(view.get(), config);\n        updateLayout();\n        // set starting page\n        setPage(0);\n        // gestures handling - load gesture_helper controller\n        zuix.load('@lib/controllers/gesture_helper', {\n            view: view,\n            on: {\n                'gesture:touch': function(e, tp) {\n                    inputCaptured = false;\n                    stopAutoSlide();\n                    dragStart();\n                    if (holdTouch) tp.cancel();\n                },\n                'gesture:release': function(e, tp) {\n                    dragStop(tp);\n                    resetAutoSlide();\n                },\n                'gesture:tap': handleTap,\n                'gesture:pan': handlePan,\n                'gesture:swipe': handleSwipe\n            }\n        });\n        // public component methods\n        cp.expose('page', function(number) {\n            if (number == null) {\n                return parseInt(currentPage);\n            } else setPage(number, DEFAULT_PAGE_TRANSITION);\n        }).expose('get', function(number) {\n            return pageList.eq(number);\n        }).expose('slide', function(activate) {\n            if (activate === true) {\n                resetAutoSlide();\n            } else stopAutoSlide();\n        }).expose('layout', function(mode) {\n            if (mode == null) {\n                return layoutType;\n            } else if (mode === LAYOUT_VERTICAL) {\n                layoutType = LAYOUT_VERTICAL;\n            } else layoutType = LAYOUT_HORIZONTAL;\n            updateLayout();\n        }).expose('refresh', function() {\n            updateLayout();\n        }).expose('next', next)\n            .expose('prev', prev)\n            .expose('last', last)\n            .expose('first', first);\n    };\n\n    cp.destroy = function() {\n        if (domObserver != null) {\n            domObserver.disconnect();\n        }\n    };\n\n    function updateLayout() {\n        if (updateLayoutTimeout != null) {\n            clearTimeout(updateLayoutTimeout);\n        }\n        updateLayoutTimeout = setTimeout(layoutElements, 250);\n    }\n    function layoutElements() {\n        if (isDragging || componentizeInterval != null) {\n            updateLayout();\n            return;\n        }\n        // init elements\n        pageList.each(function(i, el) {\n            this.css({\n                'position': 'absolute',\n                'left': 0,\n                'top': 0\n            });\n        });\n        // measure\n        const viewSize = getSize(cp.view().get());\n        if (viewSize.width === 0 || viewSize.height === 0) {\n            // cannot measure view, try again later\n            updateLayout();\n            return;\n        }\n        // position elements\n        let offset = 0;\n        pageList.each(function(i, el) {\n            let size = getSize(el);\n            if (layoutType === LAYOUT_HORIZONTAL) {\n                transition(this, DEFAULT_PAGE_TRANSITION);\n                position(this, offset, 0);\n                offset += size.width;\n            } else {\n                transition(this, DEFAULT_PAGE_TRANSITION);\n                position(this, 0, offset);\n                offset += size.height;\n            }\n        });\n        // focus to current page\n        setPage(currentPage);\n        // start automatic slide\n        if (pageList.length() > 1) {\n            resetAutoSlide();\n        }\n    }\n\n    function next() {\n        let isLast = false;\n        let page = parseInt(currentPage)+1;\n        if (page >= pageList.length()) {\n            page = pageList.length()-1;\n            isLast = true;\n        }\n        setPage(page, DEFAULT_PAGE_TRANSITION);\n        return !isLast;\n    }\n    function prev() {\n        let isFirst = false;\n        let page = parseInt(currentPage)-1;\n        if (page < 0) {\n            page = 0;\n            isFirst = true;\n        }\n        setPage(page, DEFAULT_PAGE_TRANSITION);\n        return !isFirst;\n    }\n    function first() {\n        setPage(0, DEFAULT_PAGE_TRANSITION);\n    }\n    function last() {\n        setPage(pageList.length()-1, DEFAULT_PAGE_TRANSITION);\n    }\n\n    function slideNext() {\n        setPage(parseInt(currentPage) + slideDirection, DEFAULT_PAGE_TRANSITION);\n        resetAutoSlide();\n    }\n\n    function resetAutoSlide(timeout) {\n        stopAutoSlide();\n        if (enableAutoSlide === true) {\n            const visible = cp.view().position().visible;\n            if (visible) {\n                if (!wasVisible) {\n                    zuix.componentize(cp.view());\n                }\n                slideTimeout = setTimeout(slideNext, slideIntervalMs);\n            } else {\n                slideTimeout = setTimeout(resetAutoSlide, 500);\n            }\n            wasVisible = visible;\n        }\n    }\n    function stopAutoSlide() {\n        if (slideTimeout != null) {\n            clearTimeout(slideTimeout);\n        }\n    }\n\n    function getItemIndexAt(x, y) {\n        let focusedPage = 0;\n        pageList.each(function(i, el) {\n            let data = getData(this);\n            focusedPage = i;\n            const size = data.size;\n            const rect = {\n                x: data.position.x,\n                y: data.position.y,\n                w: size.width,\n                h: size.height\n            };\n            if ((layoutType === LAYOUT_HORIZONTAL && (rect.x > x || rect.x+rect.w > x))\n                || (layoutType === LAYOUT_VERTICAL && (rect.y > y || rect.y+rect.h > y))) {\n                return false;\n            }\n        });\n        return focusedPage;\n    }\n\n    function focusPageAt(tp, transition) {\n        let vp = cp.view().position();\n        let page = getItemIndexAt(tp.x-vp.x, tp.y-vp.y);\n        setPage(page, transition != null ? transition : DEFAULT_PAGE_TRANSITION);\n    }\n\n    function setPage(n, transition) {\n        oldPage = currentPage;\n        if (n < 0) {\n            slideDirection = SLIDE_DIRECTION_FORWARD;\n            n = 0;\n        } else if (n >= pageList.length()) {\n            slideDirection = SLIDE_DIRECTION_BACKWARD;\n            n = pageList.length() - 1;\n        } else if (n !== currentPage) {\n            slideDirection = (currentPage < n) ? SLIDE_DIRECTION_FORWARD : SLIDE_DIRECTION_BACKWARD;\n        }\n        currentPage = n;\n        if (currentPage != oldPage) {\n            pageList.eq(currentPage).css('z-index', 1);\n            if (oldPage !== -1) {\n                pageList.eq(oldPage).css('z-index', 0);\n            }\n            cp.trigger('page:change', {in: currentPage, out: oldPage});\n        }\n        const el = pageList.eq(n);\n        const data = getData(el);\n        const elSize = data.size;\n        const viewSize = getSize(cp.view().get());\n        const focusPoint = {\n            x: (viewSize.width - elSize.width) / 2 - data.position.x,\n            y: (viewSize.height - elSize.height) / 2 - data.position.y\n        };\n        flyTo(focusPoint, transition);\n        resetAutoSlide();\n    }\n\n    function flyTo(targetPoint, transition) {\n        const viewSize = getSize(cp.view().get());\n        const spec = getFrameSpec();\n        const firstData = getData(pageList.eq(0));\n        const lastPage = pageList.eq(pageList.length() - 1);\n        const lastData = getData(lastPage);\n\n        pageList.each(function(i, el) {\n            const data = getData(this);\n            const frameSpec = getFrameSpec();\n            data.dragStart = {\n                x: frameSpec.marginLeft + data.position.x,\n                y: frameSpec.marginTop + data.position.y\n            };\n        });\n\n        if (layoutType === LAYOUT_HORIZONTAL) {\n            let x = targetPoint.x;\n            if (firstData.position.x + targetPoint.x > 0) {\n                x = -firstData.position.x;\n            } else {\n                if (lastData.position.x + lastPage.get().offsetWidth + targetPoint.x < viewSize.width) {\n                    x = -spec.marginLeft*2 + viewSize.width - (lastData.position.x + lastPage.get().offsetWidth);\n                }\n            }\n            if (targetPoint.x-x !== 0 && transition != null) {\n                transition = {\n                    duration: transition.duration,\n                    easing: transition.easing\n                };\n                transition.duration *= (x / targetPoint.x);\n                if (transition.duration < 0) transition.duration = 0.15;\n            }\n            dragShift(x, 0, transition);\n        } else {\n            let y = targetPoint.y;\n            if (firstData.position.y + targetPoint.y > 0) {\n                y = -firstData.position.y;\n            } else {\n                if (lastData.position.y + lastPage.get().offsetHeight + targetPoint.y < viewSize.height) {\n                    y = -spec.marginTop*2 + viewSize.height - (lastData.position.y + lastPage.get().offsetHeight);\n                }\n            }\n            if (targetPoint.y-y !== 0 && transition != null) {\n                transition = {\n                    duration: transition.duration,\n                    easing: transition.easing\n                };\n                transition.duration *= (y / targetPoint.y);\n                if (transition.duration < 0) transition.duration = 0.15;\n            }\n            dragShift(0, y, transition);\n        }\n    }\n\n    function getSize(el) {\n        const rect = el.getBoundingClientRect();\n        const width = rect.width || el.offsetWidth;\n        const height = el.offsetHeight || rect.height;\n        return {width: width, height: height};\n    }\n\n    function getData(el) {\n        const data = el.get().data = el.get().data || {};\n        const size = getSize(el.get());\n        if (size.width > 0 && size.height > 0) {\n            data.size = {\n                width: size.width,\n                height: size.height\n            };\n        } else data.size = data.size || {width: 0, height: 0};\n        data.position = data.position || {x: 0, y: 0};\n        return data;\n    }\n\n    function componentizeStart() {\n        if (isLazyContainer()) {\n            componentizeStop();\n            if (componentizeTimeout != null) {\n                clearTimeout(componentizeTimeout);\n            }\n            if (componentizeInterval != null) {\n                clearInterval(componentizeInterval);\n            }\n            componentizeInterval = setInterval(function() {\n                const viewSize = getSize(cp.view().get());\n                pageList.each(function(i, el) {\n                    // hide elements if not inside the view_pager\n                    const computed = window.getComputedStyle(el, null);\n                    const size = {\n                        width: parseFloat(computed.width.replace('px', '')),\n                        height: parseFloat(computed.height.replace('px', ''))\n                    };\n                    const x = parseFloat(computed.left.replace('px', ''));\n                    const y = parseFloat(computed.top.replace('px', ''));\n                    if (size.width > 0 && size.height > 0) {\n                        el = zuix.$(el);\n                        // check if element is inside the view_pager\n                        if (x + size.width < 0 || y + size.height < 0 || x > viewSize.width || y > viewSize.height) {\n                            if (el.visibility() !== 'hidden') {\n                                el.visibility('hidden');\n                            }\n                        } else if (el.visibility() !== 'visible') {\n                            el.visibility('visible');\n                        }\n                    }\n                });\n                zuix.componentize(cp.view());\n            }, 100);\n        }\n    }\n\n    function componentizeStop() {\n        if (isLazyContainer() && componentizeTimeout == null) {\n            clearInterval(componentizeInterval);\n        }\n    }\n\n    function dragStart() {\n        isDragging = true;\n        componentizeStart();\n        pageList.each(function(i, el) {\n            const frameSpec = getFrameSpec();\n            const data = position(this);\n            data.dragStart = {x: frameSpec.marginLeft+data.position.x, y: frameSpec.marginTop+data.position.y};\n        });\n    }\n\n    function getFrameSpec() {\n        const spec = {\n            w: 0,\n            h: 0,\n            marginLeft: 0,\n            marginTop: 0\n        };\n        const viewSize = getSize(cp.view().get());\n        pageList.each(function(i, el) {\n            const size = getSize(el);\n            spec.w += size.width;\n            spec.h += size.height;\n        });\n        if (layoutType === LAYOUT_HORIZONTAL && spec.w < viewSize.width) {\n            spec.marginLeft = (viewSize.width - spec.w) / 2;\n        } else if (layoutType === LAYOUT_VERTICAL && spec.h < viewSize.height) {\n            spec.marginTop = (viewSize.height - spec.h) / 2;\n        }\n        return spec;\n    }\n\n    function dragShift(x, y, tr) {\n        if (tr != null) {\n            componentizeStart();\n            componentizeTimeout = setTimeout(function() {\n                componentizeTimeout = null;\n                componentizeStop();\n            }, tr.duration*1000);\n            tr = tr.duration+'s '+tr.easing;\n        } else if (isLazyContainer()) {\n            zuix.componentize(cp.view());\n        }\n        pageList.each(function(i, el) {\n            const data = getData(this);\n            transition(this, tr);\n            position(this, data.dragStart.x+x, data.dragStart.y+y);\n        });\n    }\n\n    function dragStop(tp) {\n        if (enablePaging && componentizeTimeout == null) {\n            setTimeout(function() {\n                setPage(currentPage, DEFAULT_PAGE_TRANSITION);\n            }, 10);\n        }\n        if (tp != null) tp.done = true;\n        componentizeStop();\n        isDragging = false;\n    }\n\n    function isLazyContainer() {\n        const lazy = cp.view().find('[data-ui-lazyload=\"true\"]').length() > 0;\n        return lazy;\n    }\n\n    // Gesture handling\n\n    function handlePan(e, tp) {\n        if (tp.scrollMode === 0 || tp.done) {\n            return;\n        }\n        if (inputCaptured\n            || ((tp.direction === 'left' || tp.direction === 'right') && layoutType === LAYOUT_HORIZONTAL)\n            || ((tp.direction === 'up' || tp.direction === 'down') && layoutType === LAYOUT_VERTICAL)) {\n            // capture click event\n            if (!inputCaptured && tp.event.touches == null) {\n                cp.view().get().addEventListener('click', function(e) {\n                    if (inputCaptured) {\n                        inputCaptured = false;\n                        e.preventDefault();\n                        e.cancelBubble = true;\n                    }\n                    // release mouse click capture\n                    cp.view().get().removeEventListener('click', this, true);\n                }, true);\n            }\n            inputCaptured = true;\n            tp.cancel();\n        }\n        const spec = getFrameSpec();\n        if (layoutType === LAYOUT_HORIZONTAL && tp.scrollMode === 1) {\n            dragShift(tp.shiftX-spec.marginLeft, 0);\n        } else if (layoutType === LAYOUT_VERTICAL && tp.scrollMode === 2) {\n            dragShift(0, tp.shiftY-spec.marginTop);\n        }\n    }\n\n    function handleTap(e, tp) {\n        let vp = cp.view().position();\n        let page = getItemIndexAt(tp.x-vp.x, tp.y-vp.y);\n        cp.trigger('page:tap', page, tp);\n        if (enablePaging) focusPageAt(tp);\n    }\n\n    function handleSwipe(e, tp) {\n        const decelerateEasing = {\n            duration: (1+(1/Math.abs(tp.velocity))),\n            easing: 'cubic-bezier(0.1,0.45,0.35,1.1)'\n        };\n        const fly = function(destination, shift) {\n            if (enablePaging) {\n                if (layoutType === LAYOUT_HORIZONTAL) {\n                    focusPageAt({\n                        x: destination.x - shift.x,\n                        y: destination.y\n                    }, decelerateEasing);\n                } else {\n                    focusPageAt({\n                        x: destination.x,\n                        y: destination.y - shift.y\n                    }, decelerateEasing);\n                }\n            } else {\n                flyTo(shift, decelerateEasing);\n            }\n        };\n        const fastSwipe = (!enablePaging && Math.abs(tp.velocity) > 0.35) || (Math.abs(tp.velocity) > 1.25);\n        const ap = {\n            x: (tp.velocity * 1000),\n            y: (tp.velocity * 1000)\n        };\n        switch (tp.direction) {\n            case 'right':\n                if (layoutType === LAYOUT_HORIZONTAL) {\n                    if (fastSwipe) fly(tp, ap);\n                    else if (enablePaging) prev();\n                }\n                break;\n            case 'left':\n                if (layoutType === LAYOUT_HORIZONTAL) {\n                    if (fastSwipe) fly(tp, ap);\n                    else if (enablePaging) next();\n                }\n                break;\n            case 'down':\n                if (layoutType === LAYOUT_VERTICAL) {\n                    if (fastSwipe) fly(tp, ap);\n                    else if (enablePaging) prev();\n                }\n                break;\n            case 'up':\n                if (layoutType === LAYOUT_VERTICAL) {\n                    if (fastSwipe) fly(tp, ap);\n                    else if (enablePaging) next();\n                }\n                break;\n        }\n    }\n\n    function position(el, x, y) {\n        const data = getData(el);\n        if (!isNaN(x) && !isNaN(y)) {\n            data.position = {'x': x, 'y': y};\n            el.css({'left': data.position.x+'px', 'top': data.position.y+'px'});\n        }\n        return data;\n    }\n\n    function transition(el, transition) {\n        if (transition == null) {\n            transition = 'none';\n        }\n        el.css({\n            '-webkit-transition': transition,\n            '-moz-transition': transition,\n            '-ms-transition': transition,\n            '-o-transition': transition,\n            'transition': transition\n        });\n    }\n});\n"
  },
  {
    "componentId": "@lib/components/menu_overlay",
    "controller": "'use strict';\n\nzuix.controller(function(cp) {\n    let menuOverlayShowing = false;\n    let menuButtonShowing = true;\n    let menuButton;\n    let menuButtonClose;\n    let menuOverlay;\n    let itemsWrapper;\n    let menuItems;\n    let scroller = null;\n    let currentOffset = 0;\n\n    cp.create = function() {\n        menuButton = cp.field('menu_button').hide()\n            .on('click', toggleMenu);\n        menuButtonClose = cp.field('menu_button_close').hide()\n            .on('click', toggleMenu);\n        menuOverlay = cp.field('menu_overlay').visibility('hidden')\n            .on('click', toggleMenu);\n        itemsWrapper = cp.field('items_wrapper');\n\n        const items = zuix.$(cp.model().items).children();\n        items.each(function(i, el) {\n            const wrapperDiv = zuix.$(document.createElement('div'))\n                .addClass('menu-item')\n                .attr('data-ui-transition-delay', (.3/(items.length()-i))+'s')\n                .append(el);\n            itemsWrapper.append(wrapperDiv.get());\n        });\n        menuItems = itemsWrapper.find('div[class*=\"menu-item\"]');\n\n        // apply custom color to menu button\n        if (cp.view().attr('data-o-button-color') != null) {\n            cp.view().find('.circle-button').css('background', cp.view().attr('data-o-button-color'));\n        }\n        if (cp.view().attr('data-o-icon-color') != null) {\n            cp.view().find('.circle-button').css('fill', cp.view().attr('data-o-icon-color'));\n        }\n\n        const scrollerName = cp.view().attr('data-o-scroller');\n        if (scrollerName != null) {\n            scroller = zuix.field(scrollerName);\n        } else {\n            scroller = zuix.$(window);\n        }\n        if (scroller != null) {\n            scroller.on('scroll', function(e) {\n                const scrollTop = scroller.get() === window ? (document.documentElement.scrollTop || document.body.scrollTop) : scroller.get().scrollTop;\n                if (menuButtonShowing) {\n                    if ((currentOffset - scrollTop) < -2) hideButton();\n                } else if (!menuButtonShowing) {\n                    if ((currentOffset - scrollTop) > 2) showButton();\n                }\n                currentOffset = scrollTop;\n                if (menuOverlayShowing) {\n                    toggleMenu();\n                }\n            });\n        }\n\n        // Animate CSS extension\n        zuix.using('component', '@lib/extensions/animate_css', function(res, ctx) {\n            // show floating action button\n            setTimeout(function() {\n                menuButton.animateCss('slideInUp').show();\n            }, 1000);\n        });\n        // Material Design Light integration - DOM upgrade\n        if (typeof componentHandler !== 'undefined') {\n            componentHandler.upgradeElements(cp.view().get());\n        }\n\n        cp.expose('show', function() {\n            cp.view().show();\n        });\n        cp.expose('hide', function() {\n            cp.view().hide();\n        });\n        cp.expose('toggleButton', toggleButton);\n        cp.expose('showButton', showButton);\n        cp.expose('hideButton', hideButton);\n    };\n\n    function toggleButton() {\n        if (menuButtonShowing) {\n            hideButton();\n        } else {\n            showButton();\n        }\n    }\n\n    function hideButton() {\n        menuButtonShowing = false;\n        menuButton.animateCss('fadeOutDown', {duration: '0.3s'}, function() {\n            this.hide();\n        });\n        cp.trigger('hide');\n    }\n\n    function showButton() {\n        menuButtonShowing = true;\n        menuButton.animateCss('fadeInUp').show();\n        cp.trigger('show');\n    }\n\n    function toggleMenu() {\n        if (!menuOverlayShowing) {\n            menuOverlayShowing = true;\n            cp.trigger('open');\n            menuButton.animateCss('rotateOut', {duration: '0.3s'});\n            menuButtonClose.animateCss('rotateIn', {duration: '0.3s'}, function() {\n                menuButton.hide();\n            }).show();\n            menuOverlay.animateCss('fadeIn', {duration: '0.5s'}).visibility('');\n            menuItems.each(function(p, el) {\n                let transitionDelay = '0';\n                if (this.attr('data-ui-transition-delay') != null) {\n                    transitionDelay = this.attr('data-ui-transition-delay');\n                }\n                this.animateCss('bounceInRight', {duration: '0.5s', delay: transitionDelay});\n            });\n        } else if (menuOverlayShowing) {\n            menuOverlayShowing = false;\n            cp.trigger('close');\n            if (menuButtonShowing) {\n                menuButtonClose.animateCss('rotateOut', {duration: '0.3s'}, function() {\n                    this.hide();\n                });\n                menuButton.animateCss('rotateIn', {duration: '0.3s'});\n            } else {\n                menuButtonClose.animateCss('fadeOutDown', {duration: '0.3s'}, function() {\n                    this.hide();\n                });\n            }\n            menuOverlay.animateCss('fadeOut', {duration: '0.5s', delay: '0.2s'}, function() {\n                this.visibility('hidden');\n            });\n            menuItems.each(function(p, el) {\n                let transitionDelay = '0';\n                if (this.attr('data-ui-transition-delay') != null) {\n                    transitionDelay = this.attr('data-ui-transition-delay');\n                }\n                this.animateCss('fadeOutRight', {duration: '0.5s', delay: transitionDelay});\n            });\n            menuButton.show();\n        }\n    }\n});\n",
    "css": ".menu-button {\n    z-index: 100; /* topmost */\n    position: fixed;\n    right: 32px;\n    bottom: 32px;\n}\ndiv[data-ui-field=\"menu_overlay\"] {\n    z-index: 100; /* topmost */\n    position: fixed;\n    left: 0;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    padding-top: 80px;\n    padding-bottom: 96px;\n    padding-left: 32px;\n    background-color: rgba(255, 255, 255, 0.85);\n    display: flex;\n    justify-content: space-between;\n    flex-direction: column-reverse;\n}\ndiv[data-ui-field=\"items_wrapper\"] {\n    text-align: right;\n    margin-top: auto;\n}\n\n.menu-item {\n    padding-top: 8px;\n    padding-bottom: 8px;\n    margin-right: 32px;\n}\n\n.circle-button {\n    border-radius: 50%;\n    width: 56px;\n    height: 56px;\n    margin: 4px;\n    background: deeppink;\n    fill: white;\n    box-shadow: 0 4px 8px rgba(0,0,0,0.25), 0 2px 4px rgba(0,0,0,0.5);\n    vertical-align: middle;\n    text-align: center;\n    font-size: 0;\n    display: table-cell;\n    transition: all 0.3s cubic-bezier(.25,.8,.25,1);\n}\n\n@media only screen and (max-width: 640px) {\n    .menu-button {\n        right: 16px;\n        bottom: 16px;\n    }\n    .menu-item {\n        margin-right: 16px;\n    }\n    div[data-ui-field=\"menu_overlay\"] {\n        padding-bottom: 72px;\n    }\n}"
  },
  {
    "componentId": "@lib/controllers/gesture_helper",
    "controller": "/**\n * zUIx - Gesture Controller\n *\n * @version 1.0.0 (2018-03-11)\n * @author Gene\n *\n */\n\n'use strict';\n\nzuix.controller(function(cp) {\n    const SCROLL_MODE_NONE = 0;\n    const SCROLL_MODE_HORIZONTAL = 1;\n    const SCROLL_MODE_VERTICAL = 2;\n    const GESTURE_TAPTIMEOUT = 750;\n\n    let scrollMode = SCROLL_MODE_NONE;\n    let touchPointer = null;\n    let ignoreSession = false;\n    let currentGesture = null;\n    let swipeDirection = null;\n    let mouseButtonDown = false;\n    let lastTapTime = new Date().getTime();\n\n    // Math.sign Polyfill\n    Math.sign = Math.sign || function(x) {\n        return ((x>0)-(x<0))||+x;\n    };\n\n    cp.init = function() {\n        cp.options().html = false;\n        cp.options().css = false;\n    };\n\n    cp.create = function() {\n        // TODO: should use event \"capturing\" instead of \"bubbling\"\n        cp.view().on('dragstart', function(e) {\n            if (!ignoreSession) {\n                e.preventDefault();\n            }\n        }).on('mousedown', function(e) {\n            const targetElement = zuix.$(e.target);\n            if (e.which === 1 && targetElement.parent('[class*=\"no-gesture\"]').length() === 0) {\n                mouseButtonDown = true;\n                ignoreSession = false;\n                touchStart(e, e.x, e.y);\n            } else ignoreSession = true;\n        }).on('mousemove', function(e) {\n            if (!ignoreSession && mouseButtonDown) {\n                touchMove(e, e.x, e.y);\n            }\n        }).on('mouseup', function(e) {\n            if (e.which === 1 && !ignoreSession) {\n                mouseButtonDown = false;\n                touchStop(e);\n            }\n        }).on('touchstart', function(e) {\n            const targetElement = zuix.$(e.target);\n            if (targetElement.parent('[class*=\"no-gesture\"]').length() === 0) {\n                ignoreSession = false;\n                touchStart(e, e.touches[0].clientX, e.touches[0].clientY);\n            } else ignoreSession = true;\n        }).on('touchmove', function(e) {\n            if (!ignoreSession) {\n                touchMove(e, e.touches[0].clientX, e.touches[0].clientY);\n            }\n        }).on('touchend', function(e) {\n            if (!ignoreSession) {\n                touchStop(e);\n            }\n        });\n    };\n\n    function touchStart(e, x, y) {\n        let timestamp = new Date().getTime();\n        touchPointer = {\n            // original event + cancel method\n            event: e,\n            cancel: function() {\n                touchPointer.event.cancelBubble = true;\n                touchPointer.event.preventDefault();\n            },\n            // initial touch position\n            startX: x,\n            startY: y,\n            startTime: timestamp,\n            // relative movement\n            shiftX: 0,\n            shiftY: 0,\n            endTime: 0,\n            // relative movement at every step\n            stepX: 0,\n            stepY: 0,\n            stepTime: timestamp,\n            // actual position and speed\n            velocity: 0,\n            x: x,\n            y: y\n        };\n        cp.trigger('gesture:touch', touchPointer);\n    }\n    function touchMove(e, x, y) {\n        if (touchPointer != null) {\n            touchPointer.event = e;\n            touchPointer.x = x;\n            touchPointer.y = y;\n            touchPointer.shiftX = (x - touchPointer.startX);\n            touchPointer.shiftY = (y - touchPointer.startY);\n            touchPointer.endTime = new Date().getTime();\n            // detect actual gesture\n            let gesture = detectGesture();\n            if (gesture != null && currentGesture !== false) {\n                if (swipeDirection != null && swipeDirection !== touchPointer.direction) {\n                    // stop gesture detection if not coherent\n                    currentGesture = false;\n                    swipeDirection = touchPointer.direction = 'cancel';\n                } else {\n                    currentGesture = gesture;\n                    swipeDirection = touchPointer.direction;\n                }\n            }\n            cp.trigger('gesture:pan', touchPointer);\n        }\n    }\n\n    function touchStop(e) {\n        if (touchPointer != null) {\n            touchPointer.event = e;\n            if (currentGesture == null) {\n                currentGesture = detectGesture();\n            }\n            if (currentGesture != null && currentGesture !== false) {\n                cp.trigger(currentGesture, touchPointer);\n            }\n        }\n        cp.trigger('gesture:release', touchPointer);\n        scrollMode = SCROLL_MODE_NONE;\n        swipeDirection = null;\n        currentGesture = null;\n        touchPointer = null;\n    }\n\n    function detectGesture() {\n        let gesture = null;\n        const elapsedTime = touchPointer.endTime-touchPointer.stepTime;\n        const l = {x: (touchPointer.shiftX-touchPointer.stepX), y: (touchPointer.shiftY-touchPointer.stepY)};\n        const d = Math.sqrt(l.x*l.x+l.y*l.y);\n        touchPointer.velocity = (d/elapsedTime);\n        const minDistance = 5;\n        const angle = Math.atan2(touchPointer.shiftY-touchPointer.stepY, touchPointer.shiftX-touchPointer.stepX) * 180 / Math.PI;\n        if ((touchPointer.shiftX) === 0 && (touchPointer.shiftY) === 0 && touchPointer.startTime > lastTapTime+100 && elapsedTime < GESTURE_TAPTIMEOUT) {\n            // gesture TAP\n            lastTapTime = new Date().getTime();\n            gesture = 'gesture:tap';\n        } else if ((scrollMode === SCROLL_MODE_NONE || scrollMode === SCROLL_MODE_HORIZONTAL)\n            && d > minDistance && ((angle >= 135 && angle <= 180) || (angle >= -180 && angle <= -135))) {\n            // gesture swipe RIGHT\n            touchPointer.direction = 'left';\n            touchPointer.velocity *= -1;\n            gesture = 'gesture:swipe';\n            scrollMode = SCROLL_MODE_HORIZONTAL;\n        } else if ((scrollMode === SCROLL_MODE_NONE || scrollMode === SCROLL_MODE_HORIZONTAL)\n            && d > minDistance && ((angle >= 0 && angle <= 45) || (angle >= -45 && angle < 0))) {\n            // gesture swipe LEFT\n            touchPointer.direction = 'right';\n            gesture = 'gesture:swipe';\n            scrollMode = SCROLL_MODE_HORIZONTAL;\n        } else if ((scrollMode === SCROLL_MODE_NONE || scrollMode === SCROLL_MODE_VERTICAL)\n            && d > minDistance && (angle > 45 && angle < 135)) {\n            // gesture swipe UP\n            touchPointer.direction = 'down';\n            gesture = 'gesture:swipe';\n            scrollMode = SCROLL_MODE_VERTICAL;\n        } else if ((scrollMode === SCROLL_MODE_NONE || scrollMode === SCROLL_MODE_VERTICAL)\n            && d > minDistance && (angle > -135 && angle < -45)) {\n            // gesture swipe DOWN\n            touchPointer.direction = 'up';\n            touchPointer.velocity *= -1;\n            gesture = 'gesture:swipe';\n            scrollMode = SCROLL_MODE_VERTICAL;\n        }\n        touchPointer.scrollMode = scrollMode;\n        // reset touch step data\n        if (d > minDistance) {\n            touchPointer.stepTime = touchPointer.endTime;\n            touchPointer.stepX = touchPointer.shiftX;\n            touchPointer.stepY = touchPointer.shiftY;\n        }\n        return gesture;\n    }\n});\n"
  },
  {
    "componentId": "@lib/controllers/scroll_helper",
    "controller": "/**\n * ZUIX - ScrollHelper Controller\n *\n * @version 1.1.0 (2018-04-22)\n * @author Gene\n *\n * @version 1.0.1 (2017-06-16)\n * @author Gene\n *\n */\n\n'use strict';\n\nzuix.controller(function(cp) {\n    const scrollInfo = {\n        timestamp: 0,\n        size: {\n            width: 0,\n            height: 0\n        },\n        viewport: {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        }\n    };\n    let updateTimeout;\n    let watchList;\n    let watchCallback;\n    let scrollToEndTs = 0;\n\n    cp.init = function() {\n        cp.options().html = false;\n        cp.options().css = false;\n    };\n\n    cp.create = function() {\n        if (cp.view().get() === document.body) {\n            if (cp.options().throttle > 0) {\n                window.onscroll = throttle(scrollCheck, cp.options().throttle);\n            } else {\n                window.onscroll = scrollCheck;\n            }\n        } else {\n            if (cp.options().throttle > 0) {\n                cp.view().on('scroll', throttle(scrollCheck, cp.options().throttle));\n            } else {\n                cp.view().on('scroll', scrollCheck);\n            }\n        }\n        cp.expose('watch', function(filter, callback) {\n            setWatchList(filter, callback);\n            return cp.context;\n        });\n        cp.expose('scrollStart', function(duration) {\n            if (duration == null) duration = -1;\n            scrollTo(0, duration);\n            return cp.context;\n        }).expose('scrollEnd', function(duration) {\n            if (duration == null) duration = -1;\n            scrollTo(scrollInfo.size.height, duration);\n            return cp.context;\n        }).expose('scrollTo', function(to, duration) {\n            if (duration == null) duration = -1;\n            scrollTo(to, duration);\n            return cp.context;\n        }).expose('info', function() {\n            return scrollInfo;\n        });\n        // TODO: that's a temp hack to force measure at start\n        scrollTo(5, -1);\n        scrollTo(0, 200);\n    };\n\n    let frameSkipTs;\n    function scrollCheck() {\n        // TODO: implement code for horizontal scroll as well\n\n        if (updateTimeout != null) {\n            clearTimeout(updateTimeout);\n        }\n        const now = new Date().getTime();\n        if (now - scrollInfo.timestamp > 100) {\n            updateScrollInfo();\n        } else {\n            updateTimeout = setTimeout(function() {\n                updateScrollInfo();\n            }, 99);\n        }\n\n        if (now < scrollToEndTs && now-frameSkipTs < 66) {\n            return;\n        }\n        frameSkipTs = now;\n\n        const scrollable = cp.view().get();\n        const visibleClass = 'scroll-helper-visible';\n        if (watchList != null && watchCallback != null) {\n            watchList.each(function(i, el) {\n\n                // TODO: replace this code using the new \"zuix.$(el).position()\" method\n\n                const position = this.position();\n\n                let visible = false;\n                let tolerance = 0;\n                if (el.offsetParent === null) {\n                    // not attached yet.\n                    return false;\n                }\n                if (tolerance == null) tolerance = 0;\n\n                const r1 = {\n                    left: 0,\n                    top: 0,\n                    right: scrollInfo.viewport.width,\n                    bottom: scrollInfo.viewport.height,\n                    width: scrollInfo.viewport.width,\n                    height: scrollInfo.viewport.height\n                };\n                let r2 = el.getBoundingClientRect();\n                let parent = el.offsetParent;\n                while (parent !== null && parent !== scrollable) {\n                    const pr = parent.getBoundingClientRect();\n                    r2 = {\n                        left: r2.left + pr.left,\n                        top: r2.top + pr.top,\n                        right: r2.right + pr.left,\n                        bottom: r2.bottom + pr.top,\n                        width: r2.width,\n                        height: r2.height\n                    };\n                    parent = parent.offsetParent;\n                }\n\n                visible = !(r2.left > r1.right-tolerance ||\n                    r2.right < r1.left+tolerance ||\n                    r2.top > r1.bottom-tolerance ||\n                    r2.bottom < r1.top+tolerance);\n\n                position.frame = {\n                    dx: (r2.left+(r2.width/2)-r1.left)/r1.width,\n                    dy: (r2.top+(r2.height/2)-r1.top)/r1.height\n                };\n                position.visible = visible;\n\n                if (!visible && this.hasClass(visibleClass)) {\n                    this.removeClass(visibleClass);\n                    position.event = 'exit';\n                } else if (!visible) {\n                    position.event = 'off-scroll';\n                } else if (visible) {\n                    if (!this.hasClass(visibleClass)) {\n                        position.event = 'enter';\n                        this.addClass(visibleClass);\n                    } else position.event = 'scroll';\n                } else return;\n                watchCallback(this, position);\n            });\n        }\n    }\n\n    function setWatchList(filter, callback) {\n        if (filter != null) {\n            watchList = cp.view(filter);\n            watchCallback = callback;\n        } else {\n            watchList = null;\n            watchCallback = null;\n        }\n    }\n\n    function updateScrollInfo() {\n        const scrollable = cp.view().get();\n        const vp = scrollable.getBoundingClientRect();\n        vp.y = cp.view().get().scrollTop | vp.y;\n        vp.height = cp.view().get().scrollHeight | vp.height;\n        scrollInfo.size.width = vp.width;\n        scrollInfo.size.height = vp.height;\n        if (scrollable === document.body) {\n            scrollInfo.size.width = document.body.offsetWidth;\n            scrollInfo.size.height = document.body.offsetHeight;\n            scrollInfo.viewport.width = document.documentElement.offsetWidth;\n            scrollInfo.viewport.height = document.documentElement.offsetHeight;\n        } else {\n            scrollInfo.viewport.width = scrollable.offsetWidth;\n            scrollInfo.viewport.height = scrollable.offsetHeight;\n        }\n        scrollInfo.timestamp = new Date().getTime();\n        scrollInfo.shift = {\n            x: vp.x - scrollInfo.viewport.x,\n            y: vp.y - scrollInfo.viewport.y\n        };\n        scrollInfo.viewport.x = vp.x;\n        scrollInfo.viewport.y = vp.y;\n        const endScroll = scrollInfo.size.height+vp.y-scrollInfo.viewport.height;\n        if ((endScroll === 0 || vp.y === 0)) {\n            cp.trigger('scroll:change', {event: vp.y === 0 ? 'hit-top' : 'hit-bottom', info: scrollInfo});\n        } else {\n            cp.trigger('scroll:change', {event: 'scroll', info: scrollInfo});\n        }\n    }\n\n    function scrollTo(to, duration) {\n        if (to instanceof Element || to instanceof zuix.$.ZxQuery) {\n            to = zuix.$(to).position().y - scrollInfo.viewport.y;\n        }\n        if (duration === -1) {\n            return setScroll(to);\n        }\n        const currentTs = Date.now();\n        if (duration != null) {\n            scrollToEndTs = currentTs + duration;\n        }\n        duration = scrollToEndTs-currentTs;\n\n        const el = cp.view().get();\n        let scrollTop = 0;\n        if (el === document.body) {\n            scrollTop = (window.pageYOffset !== undefined)\n                ? window.pageYOffset\n                : (document.documentElement || document.body.parentNode || document.body).scrollTop;\n        } else scrollTop = el.scrollTop;\n\n        const difference = to - scrollTop;\n        if (duration <= 0 || difference === 0) {\n            setScroll(to);\n            scrollCheck();\n            return;\n        }\n\n        const offset = scrollTop + (difference / duration * 33);\n        requestAnimationFrame(function() {\n            setScroll(offset);\n            scrollTo(to);\n        });\n    }\n\n    function setScroll(to) {\n        const el = cp.view().get();\n        if (el === document.body) {\n            document.documentElement.scrollTop = to;\n            document.body.scrollTop = to;\n        } else el.scrollTop = to;\n    }\n\n    function throttle(func, limit) {\n        let lastFunc = void 0;\n        let lastRan = void 0;\n        return function() {\n            const context = this;\n            const args = arguments;\n            if (!lastRan) {\n                func.apply(context, args);\n                lastRan = Date.now();\n            } else {\n                clearTimeout(lastFunc);\n                lastFunc = setTimeout(function() {\n                    if (Date.now() - lastRan >= limit) {\n                        func.apply(context, args);\n                        lastRan = Date.now();\n                    }\n                }, limit - (Date.now() - lastRan));\n            }\n        };\n    }\n});\n"
  }
])</script>
</body></html>