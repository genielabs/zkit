<!DOCTYPE html><html lang="en"><head>
    <title>zKit: Gesture Helper (lib/controllers)</title>

    <meta content="text/html; charset=utf-8" http-equiv="content-type">
    <meta http-equiv="Content-Language" content="en-us">

    <meta name="description" content="zKit, a collection of framework-agnostic components for modern web.">
    <meta name="keywords" lang="en-us" content="web components,polymer,react,react.js,angular,angular.js,ember,ember.js,vue,vue.js,meteor,meteor.js,web app,pwa,progressive,web application,modern web,framework,javascript,library,content manager,component manager,web app,content authoring,web master,static site,spa,single page application,content loader,content include,material,material design lite,mdl">
    <meta name="author" content="G-Labs">

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,user-scalable=no">

    <!-- Add to homescreen for Chrome on Android -->
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="icon" sizes="192x192" href="../../../images/android-desktop.png">

    <!-- Add to homescreen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Material Design Lite">
    <link rel="apple-touch-icon-precomposed" href="../../../images/ios-desktop.png">

    <!-- Tile icon for Win8 (144x144 + tile color) -->
    <meta name="msapplication-TileImage" content="../../../images/touch/ms-touch-icon-144x144-precomposed.png">
    <meta name="msapplication-TileColor" content="#3372DF">

    <link rel="shortcut icon" href="../../../images/favicon.png">

    <meta name="google-site-verification" content="nkLa1C34WpSqkoDdFA0-rdb_tz412T9bAMZK7Uzu4y4">
    <!-- SEO: If your mobile URL is different from the desktop URL, add a canonical link to the desktop page https://developers.google.com/webmasters/smartphone-sites/feature-phones -->
    <!--
    <link rel="canonical" href="https://www.example.com/">
    -->

    <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="../../../css/flex-layout-attribute.min.css">

    <!-- zUIx library  -->
    <script src="../../../js/zuix/zuix.min.js"></script>
    <!--script src="../../../config.js"></script-->


<script>
    // use 'var' or 'window.' for options (global object)
</script>

    <style>[data-ui-view] { display: none; }</style>
</head>

<body layout="column top-center">

<header class="header-cover animated fadeIn">
    <div self="size-large center" layout="rows center-left">
        <div><h1 data-ui-field="page_title" class="animated fadeInLeft">Gesture Helper</h1></div>
        <div self="center-right"><a href="../../../"><i class="material-icons animated fadeInRight">extension</i></a></div>
    </div>
</header>





<main self="size-x1 stretch" class="main-content animated fadeIn" layout="columns top-stretch">

    

<div self="size-large center">

    <p>
        Detect tap and swipe gestures over elements.
    </p>
    <div data-ui-load="@lib/controllers/gesture_helper" data-ui-options="gesture_opts" layout="column center-center" self="center" class="no-select gesture-box">
        <!-- gesture detection area -->
        <div data-ui-field="gesture-xy"></div>
        <div data-ui-field="gesture-shift"></div>
        <div data-ui-field="gesture" layout="row center-center">Try me!</div>
    </div>

</div>
<script>
    var gesture_opts = {
        ready: function() {
            let gh = this;
            let view = zuix.$(gh.view());
            let infoXy = zuix.field('gesture-xy');
            let infoShift = zuix.field('gesture-shift');
            let info = zuix.field('gesture');
            view.css('opacity', 1.0);
            // register event callbacks
            gh.on('gesture:touch', function(e, tp) {
                view.addClass('active');
                info.html('touch').animateCss('flash');
                tp.cancel();
            }).on('gesture:pan', function(e, tp) {
                infoXy.show().html(Math.round(tp.x)+' ; '+Math.round(tp.y));
                infoShift.show().html(Math.round(tp.shiftX)+' ;'+Math.round(tp.shiftY));
                info.html('pan').animateCss('fadeIn');
            }).on('gesture:release', function(e, tp) {
                view.removeClass('active');
                infoXy.hide();
                infoShift.hide();
            }).on('gesture:tap', function(e, tp) {
                info.html('tap').animateCss('tada');
            }).on('gesture:swipe', function(e, tp) {
                info.html('swipe <i class="material-icons animated tada">keyboard_arrow_'+tp.direction+'</i> '+tp.direction);
            });
        }
    };
</script>
<style>
    .gesture-box {
        border: solid 2px rgba(255,255,255,0.5);
        position: relative;
        background: #5f99cf;
        border-radius: 16px;
        width: 70%;
        height: 140px;
        color: white;
        font-size: 160%;
        line-height: 120%;
        margin: 32px 16px 16px;
        font-family: Helvetica, sans-serif;
        cursor: -webkit-grab;
        cursor: -moz-grab;
        cursor: grab;
        -webkit-box-shadow: 0 0 40px -8px rgba(0,0,0,0.75);
        -moz-box-shadow: 0 0 40px -8px rgba(0,0,0,0.75);
        box-shadow: 0 0 40px -8px rgba(0,0,0,0.75);
        opacity: 0.75;
    }
    .gesture-box.active {
        -webkit-box-shadow: 0 0 20px -2px rgba(0,0,0,0.75);
        -moz-box-shadow: 0 0 20px -2px rgba(0,0,0,0.75);
        box-shadow: 0 0 20px -2px rgba(0,0,0,0.75);
        opacity: 1.0;
    }
    [data-ui-field="gesture"] {
        transition: 0.1s ease-out;
    }
    [data-ui-field="gesture"] i {
        font-size: 300%;
        color: lime;
    }
    [data-ui-field="gesture-xy"] {
        position: absolute;
        top: 8px; left: 16px;
        font-size: 50%;
        font-weight: 700;
    }
    [data-ui-field="gesture-shift"] {
        position: absolute;
        top: 8px; right: 16px;
        font-size: 50%;
        font-weight: 700;
    }
</style>

<div self="size-large center" layout="columns top-stretch">

    <h2>Usage</h2>
<h3>1. Include zUIx library</h3>
<p>Add the following line, preferably inside the <code>head</code> section of the <code>HTML</code> document:</p>

<pre><code class="html">&lt;script src="//genielabs.github.io/zuix/js/zuix.min.js"&gt;&lt;/script&gt;</code></pre>


    <h3>2. Load the gesture helper on the target element</h3>
    <p>Add the <code>data-ui-load</code> attribute to the element you want to detect gesture on</p>
<pre><code class="html">&lt;div data-ui-load="@lib/controllers/gesture_helper"
     data-ui-options="gesture_options"&gt;
    <!-- gesture detection area -->
&lt;/div&gt;
<script>
var gesture_options = {
  ready: function() {
    // register event callbacks
    this.on('gesture:touch', function(e, tp) {
      // TODO: handle touch
    }).on('gesture:pan', function(e, tp) {
      // TODO: handle pan
    }).on('gesture:release', function(e, tp) {
      // TODO: handle release
    }).on('gesture:tap', function(e, tp) {
      // TODO: handle tap
    }).on('gesture:swipe', function(e, tp) {
      // TODO: handle swipe
      switch(tp.direction) {
        case 'up':
          break;
        case 'down':
          break;
        case 'left':
          break;
        case 'right':
          break;
      }
    });
  }
}
</script></code></pre>
    <p>
        Callbacks will receive the <code>tp</code> <em>(TouchPointer)</em> parameter
    </p>
<pre><code class="js">tp = {
  // time frame
  startTime,
  endTime,
  // initial touch position
  startX,
  startY,
  // relative movement
  shiftX,
  shiftY,
  // actual direction, speed, position
  direction, // 'left' | 'right' | 'up' | 'down'
  velocity,
  x: x,
  y: y,
  // original event + cancel method
  event,
  cancel()
};</code></pre>

    <h2>Option attributes</h2>
    <ul>
        <li>
            <code class="option">data-ui-load="@lib/controllers/gesture_helper"</code>
            <small>constructor</small><br>
            load the <code>gesture_helper</code> controller on the element.
        </li>
        <li>
            <code class="option">data-ui-context</code>
            <small>optional</small><br>
            identifier name to be used to reference this component from JavaScript.
        </li>
    </ul>


    <h2>Source code</h2>
    <p>
        Source code is available in the <code>lib/controllers</code> folder of <a href="//github.com/genielabs/zkit">zKit</a> repository.
    </p>
    <div self="size-large">
        <ul class="list">
            <li><a href="//github.com/genielabs/zkit/blob/master/source/lib/controllers/gesture_helper.js">gesture_helper.js</a></li>
        </ul>
    </div>

</div>



</main>

<footer layout="column center-center">
    <div layout="rows center-justify" class="footer-block">
        <div self="size-x1 center-right"><a href="../../../"><strong>zKit</strong></a> <small>components for modern web</small></div>
        <div self="center-right">made with <strong><a href="http://zuix.it">zUIx</a></strong></div>
    </div>
</footer>






<!-- Global site tag (gtag.js) - Google Analytics -->
<script async="" src="//www.googletagmanager.com/gtag/js?id=UA-116384214-1"></script>
<script>
    // Google Analytics
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-116384214-1');
</script>

<!-- MDL -->
<link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.indigo-pink.min.css">
<script defer="" src="https://code.getmdl.io/1.3.0/material.min.js"></script>


<link rel="stylesheet" href="../../..//css/docs.css">

<!-- Common JS scripts -->
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.12.0/build/styles/androidstudio.min.css">
<script>
    // Escape HTML in 'code' blocks
    document.querySelectorAll("code").forEach(function(element) {
        element.innerHTML = element.innerHTML/*.replace(/&/g, "&amp;")*/.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
    });
    // AnimateCSS
    zuix.using('component', '@lib/extensions/animate_css');
    // Code highlighting
    zuix.using('script', '//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.12.0/build/highlight.min.js', function () {
        zuix.$('pre code').each(function(i, block) {
            hljs.highlightBlock(block);
        });
    });
</script>



<!-- zUIx inline resource resourceBundle -->
<!--{[@lib/components/media_browser]}-->
<div data-ui-view="@lib/components/media_browser">
<div data-ui-field="container" class="container">

    <div data-ui-load="@lib/controllers/view_pager" data-o-paging="true" data-ui-field="media" class="media-list hidden"><!-- no-view --></div>

    <div data-ui-field="controls">

        <div data-ui-load="@lib/controllers/view_pager" data-ui-field="carousel" layout="row center-left"><!-- no-view --></div>

    </div>

    <div data-ui-field="nav-close">
        <svg fill="#FFFFFF" height="48" width="48" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path>
            <path d="M0 0h24v24H0z" fill="none"></path>
        </svg>
    </div>
    <div data-ui-field="nav-prev">
        <svg fill="white" height="48" width="48" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path>
            <path d="M0 0h24v24H0z" fill="none"></path>
        </svg>
    </div>
    <div data-ui-field="nav-next">
        <svg fill="white" height="48" width="48" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"></path>
            <path d="M0 0h24v24H0z" fill="none"></path>
        </svg>
    </div>

    <div data-ui-field="progress-container">
        <div data-ui-field="load-progress"></div>
    </div>

</div>
<script></script>

</div>
<!--{[@lib/components/menu_overlay]}-->
<div data-ui-view="@lib/components/menu_overlay">
<!-- FAB menu overlay -->
<div data-ui-field="menu_overlay">
    <div data-ui-field="items_wrapper"></div>
</div>

<!-- Colored FAB menu button -->
<div data-ui-field="menu_button" class="menu-button">
    <div class="circle-button">
        <svg height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
            <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path>
            <path d="M0 0h24v24H0z" fill="none"></path>
        </svg>
    </div>
</div>
<div data-ui-field="menu_button_close" class="menu-button">
    <div class="circle-button">
        <svg height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path>
            <path d="M0 0h24v24H0z" fill="none"></path>
        </svg>
    </div>
</div>

</div>
    <script>zuix.bundle([
  {
    "componentId": "@lib/components/media_browser",
    "controller": "'use strict';\n\nzuix.controller(function(cp) {\n    let currentPage = 0;\n    let itemsListVisible = false;\n    // view_pager views\n    let fullView;\n    let listView;\n    /** @typedef {ZxQuery} */\n    let imageList;\n    /** @typedef {ZxQuery} */\n    let buttonNext;\n    /** @typedef {ZxQuery} */\n    let buttonPrev;\n    /** @typedef {ZxQuery} */\n    let buttonClose;\n\n    let youtubeApiCallbacks = [];\n    let youtubeApiReady = false;\n\n    cp.create = function() {\n        // export public component methods\n        cp.expose('open', openBrowser)\n            .expose('close', closeBrowser)\n            // .expose('items', setItems)\n            .expose('youtubeApi', function(callback) {\n                if (youtubeApiReady) callback();\n                else youtubeApiCallbacks.push(callback);\n            }).expose('current', setCurrent)\n            .expose('showControls', showControls)\n            .expose('hideControls', hideControls)\n            .expose('toggleControls', toggleControls)\n            .expose('showList', showList)\n            .expose('hideList', hideList);\n\n        cp.view().css({\n            'position': 'fixed',\n            'left': 0,\n            'right': 0,\n            'top': 0,\n            'bottom': 0,\n            'z-index': 20\n        }).hide();\n\n        // load Animate CSS extension\n        zuix.using('component', '@lib/extensions/animate_css', function() {\n            showControls();\n        });\n\n        // add youtube API\n        // This code loads the IFrame Player API code asynchronously.\n        window.onYouTubeIframeAPIReady = function() {\n            zuix.$.each(youtubeApiCallbacks, function() {\n                this();\n            });\n            youtubeApiCallbacks = [];\n            youtubeApiReady = true;\n        };\n        const tag = document.createElement('script');\n        tag.src = 'https://www.youtube.com/iframe_api';\n        const firstScriptTag = cp.view().find('script').get();\n        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);\n\n        // Main ViewPager\n        zuix.context(cp.field('media'), function() {\n            fullView = this\n                .on('gesture:tap', toggleControls)\n                .on('page:change', function(e, page) {\n                    listView.page(page.in);\n                    cp.trigger('page:change', page);\n                });\n            buttonPrev = cp.field('nav-prev').on('click', function() {\n                fullView.prev();\n            });\n            buttonNext = cp.field('nav-next').on('click', function() {\n                fullView.next();\n            });\n            buttonClose = cp.field('nav-close').on('click', closeBrowser);\n            // setup media list with thumbnails and full screen items with temporary background preview\n            imageList = cp.field('media')\n                .children().each(function(i, el) {\n                    let preview = this.find('[data-ui-field=\"preview\"]');\n                    if (preview.length() > 0) {\n                        this.css('background', 'url(\"'+preview.find('img').attr('src')+'\") scroll no-repeat center/contain');\n                        cp.field('carousel')\n                            .append(preview.detach().get());\n                    } else {\n                        // TODO: add a button or something if preview thumbnail not specified\n                        cp.field('carousel')\n                            .append(document.createElement('div'));\n                    }\n                });\n            cp.field('media').children().each(function(i, el) {\n                let type = this.attr('data-type');\n                if (type == null) type = 'image'; // default type\n                this.attr('data-ui-load', cp.context.componentId+'/'+type);\n                if (type !== 'video') {\n                    this.attr('data-ui-lazyload', true);\n                }\n                this.attr('data-index', i);\n                zuix.context(el, function() {\n                    this.host(cp.view());\n                });\n            });\n        });\n        // Carousel ViewPager\n        zuix.context(cp.field('carousel'), function() {\n            listView = this;\n            listView\n                .on('page:change', pageChanged)\n                .on('page:tap', function(e, page) {\n                    fullView.page(page);\n                });\n        });\n        // Keyboard navigation handling\n        cp.view().attr('tabindex', 0)\n            .on('blur', function() {\n                this.get().focus();\n            }).get().focus();\n        document.onkeydown = function(e) {\n            switch (e.keyCode) {\n                case 27: // esc\n                    closeBrowser();\n                    break;\n                case 32: // space\n                    toggleControls();\n                    break;\n                case 37: // left\n                    fullView.prev();\n                    break;\n                case 38: // up\n                    showControls();\n                    break;\n                case 39: // right\n                    fullView.next();\n                    break;\n                case 40: // down\n                    hideControls();\n                    break;\n            }\n        };\n    };\n\n    function pageChanged(e, page) {\n        currentPage = page.in;\n        listView.get(currentPage)\n            .attr('data-ui-lazyload', false)\n            .children().eq(0).addClass('page-active');\n        if (page.out !== -1) {\n            listView.get(page.out).children().eq(0).removeClass('page-active');\n        }\n        updateButtons();\n        // TODO: not yet sure why is this timeout required to make it work\n        setTimeout(function() {\n            zuix.componentize(cp.field('media'), listView.get(currentPage));\n        }, 200);\n    }\n\n    function setCurrent(current) {\n        return fullView.page(current);\n    }\n\n    function openBrowser() {\n        // hide navigation buttons\n        buttonClose.animateCss('rotateIn', {duration: '0.75s'});\n        buttonNext.hide();\n        buttonPrev.hide();\n        // show the media browser and update buttons\n        cp.field('media').removeClass('hidden');\n        cp.view().animateCss('zoomIn', {duration: '0.5s'}, function() {\n            // refresh ViewPager\n            fullView.refresh();\n            listView.refresh();\n            updateButtons();\n            // TODO: not yet sure why is this timeout required to make it work\n            // force load of current item\n            setTimeout(function() {\n                // make pages visible (this should run once though)\n                cp.field('media').children().each(function() {\n                    this.css('visibility', 'visible');\n                });\n                zuix.componentize(cp.field('media'), listView.get(currentPage));\n            }, 200);\n            this.trigger('open');\n        }).show();\n        return cp.context;\n    }\n\n    function closeBrowser() {\n        buttonClose.animateCss('rotateOut', {duration: '0.5s'});\n        cp.view().animateCss('zoomOut', {duration: '0.5s', delay: '0.15s'}, function() {\n            this.hide();\n        }).trigger('close');\n        return cp.context;\n    }\n\n    function updateButtons() {\n        if (imageList == null) return;\n        // show navigation buttons as needed\n        if (currentPage < imageList.length() - 1) {\n            if (buttonNext.display() === 'none') {\n                buttonNext.animateCss('fadeInRight').show();\n            }\n        } else {\n            if (buttonNext.display() !== 'none') {\n                buttonNext.animateCss('fadeOutRight', function() {\n                    this.hide();\n                });\n            }\n        }\n        if (currentPage > 0 && imageList.length() > 1) {\n            if (buttonPrev.display() === 'none') {\n                buttonPrev.animateCss('fadeInLeft').show();\n            }\n        } else {\n            if (buttonPrev.display() !== 'none') {\n                buttonPrev.animateCss('fadeOutLeft', function() {\n                    this.hide();\n                });\n            }\n        }\n        if (buttonClose.display() === 'none') {\n            buttonClose.animateCss('fadeInDown', {duration: '0.35s', delay: '0.5s'}).show();\n        }\n    }\n\n    function toggleControls(e, tp) {\n        if (tp == null || !zuix.$(tp.event.target).hasClass('capture-touch')) {\n            if (cp.field('controls').display() !== 'none') {\n                hideControls();\n            } else {\n                showControls();\n            }\n            if (tp != null) tp.cancel();\n        }\n    }\n\n    function showList() {\n        if (!itemsListVisible) {\n            itemsListVisible = true;\n            cp.field('controls').animateCss('fadeInUp').show();\n            if (listView != null && fullView != null) {\n                listView.page(fullView.page());\n            }\n            cp.trigger('controls:show');\n        }\n    }\n    function hideList() {\n        if (itemsListVisible) {\n            itemsListVisible = false;\n            cp.field('controls').animateCss('fadeOutDown', function() {\n                this.hide();\n            });\n        }\n    }\n\n    function hideControls() {\n        hideList();\n        if (buttonPrev.display() !== 'none') {\n            buttonPrev.animateCss('fadeOutLeft', function() {\n                this.hide();\n            });\n        }\n        if (buttonNext.display() !== 'none') {\n            buttonNext.animateCss('fadeOutRight', function() {\n                this.hide();\n            });\n        }\n        if (buttonClose.display() !== 'none') {\n            buttonClose.animateCss('fadeOutUp', {duration: '0.35s'}, function() {\n                this.hide();\n            });\n        }\n        cp.trigger('controls:hide');\n    }\n    function showControls() {\n        showList();\n        updateButtons();\n    }\n});\n",
    "css": ". {\n    -webkit-touch-callout: none; /* iOS Safari */\n    -webkit-user-select: none; /* Safari */\n    -khtml-user-select: none; /* Konqueror HTML */\n    -moz-user-select: none; /* Firefox */\n    -ms-user-select: none; /* Internet Explorer/Edge */\n    user-select: none; /* Non-prefixed version, currently\n                                  supported by Chrome and Opera */\n    overflow: hidden;\n}\n\n.container {\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    z-index: 20;\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -moz-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-flex-align: stretch;\n    -ms-flex-align: stretch;\n    -webkit-align-items: stretch;\n    align-items: stretch;\n    justify-content: center;\n    background: black;\n}\n\nsvg {\n    vertical-align: middle;\n}\n\n[data-ui-field=\"media\"] article {\n    visibility: hidden;\n    width: 100vw;\n    height: 100vh;\n}\n\n[data-ui-field=\"media\"] article:not([data-ui-loaded]) > * {\n    display: none;\n}\n\n[data-ui-field=\"controls\"] {\n    position: fixed;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    height: 140px;\n    z-index: 10;\n    padding-left: 10px;\n    padding-right: 10px;\n    background-color: rgba(255,255,255,0.25);\n    /*background-color: rgba(0,0,0,0.5);*/\n}\n\n[data-ui-field=\"nav-prev\"] {\n    border: solid 2px white;\n    border-radius: 48px;\n    margin: 6px;\n    position: absolute;\n    left: 12px;\n    bottom: 45%;\n    z-index: 10;\n    background-color: rgba(1,1,1,0.5);\n    opacity: 0.5;\n}\n[data-ui-field=\"nav-next\"] {\n    border: solid 2px white;\n    border-radius: 48px;\n    margin: 6px;\n    position: absolute;\n    right: 12px;\n    bottom: 45%;\n    z-index: 10;\n    background-color: rgba(1,1,1,0.5);\n    opacity: 0.5;\n}\n[data-ui-field=\"nav-close\"] {\n    position: absolute;\n    right: 16px;\n    top: 16px;\n    z-index: 10;\n    opacity: 0.5;\n}\n[data-ui-field=\"progress-container\"] {\n    position: absolute;\n    top: 32px;\n    z-index: 10;\n    width: 128px;\n    color: white;\n    font-weight: 700;\n    font-size: 32px;\n    text-align: center;\n    text-shadow:\n        -2px -2px 0 darkblue,\n        2px -2px 0 darkblue,\n        -2px 2px 0 darkblue,\n        2px 2px 0 darkblue;\n}\n\ni {\n    cursor: pointer;\n}\n\n.hidden {\n    display: none;\n}\n\n.media-list {\n    width: 100%;\n    height: 100%;\n}\n\n.above-controls {\n    margin-bottom: 80px;\n}\n\n.rounded-border {\n    border-radius: 5px;\n    -webkit-transform: scale(0.9);\n    -moz-transform: scale(0.9);\n    -ms-transform: scale(0.9);\n    -o-transform: scale(0.9);\n    transform: scale(0.9);\n}\n\n.page-active {\n    border: solid 1px rgba(255,255,255,0.9) !important;\n    -webkit-transform: scale(1.125);\n    -moz-transform: scale(1.125);\n    -ms-transform: scale(1.125);\n    -o-transform: scale(1.125);\n    transform: scale(1.125);\n}\n\n[data-ui-field=\"carousel\"] {\n    overflow: visible !important;\n    height: 100%;\n}\n\n[data-ui-field=\"preview\"] {\n    padding: 10px;\n    max-width: 100%;\n    max-height: 100%;\n}\n[data-ui-field=\"preview\"] img {\n    overflow: hidden;\n    height: 120px;\n    max-height: 120px;\n    border-radius: 8px;\n    border: solid 1px rgba(0,0,0, 0.5);\n    box-shadow: -4px 4px 16px 3px rgba(0,0,0,0.5);\n    transition: 0.1s ease-in;\n}\n\n\n@media only screen and (max-width: 820px) {\n    [data-ui-field=\"controls\"] {\n        height: 104px;\n    }\n    [data-ui-field=\"preview\"] img {\n        max-height: 80px;\n    }\n    [data-ui-field=\"nav-prev\"] {\n        left: 6px;\n    }\n    [data-ui-field=\"nav-next\"] {\n        right: 6px;\n    }\n    [data-ui-field=\"nav-close\"] {\n        right: 12px;\n        top: 12px;\n    }\n}"
  },
  {
    "componentId": "@lib/controllers/view_pager",
    "controller": "/**\n * zUIx - ViewPager Component\n *\n * @version 1.0.2 (2018-06-25)\n * @author Gene\n *\n * @version 1.0.1 (2018-02-12)\n * @author Gene\n *\n */\n\n'use strict';\n\nzuix.controller(function(cp) {\n    const DEFAULT_PAGE_TRANSITION = {duration: 0.3, easing: 'ease'};\n    const LAYOUT_HORIZONTAL = 'horizontal';\n    const LAYOUT_VERTICAL = 'vertical';\n    const SLIDE_DIRECTION_FORWARD = 1;\n    const SLIDE_DIRECTION_BACKWARD = -1;\n    // state vars\n    let currentPage = -1;\n    let oldPage = 0;\n    let slideTimeout = null;\n    let slideIntervalMs = 3000;\n    let slideDirection = SLIDE_DIRECTION_FORWARD;\n    let updateLayoutTimeout = null;\n    let inputCaptured = false;\n    // options\n    let layoutType = LAYOUT_HORIZONTAL;\n    let enableAutoSlide = false;\n    let enablePaging = false;\n    let holdTouch = false;\n    let isDragging = false;\n    let wasVisible = false;\n    let componentizeInterval = null;\n    let componentizeTimeout = null;\n    /** @typedef {ZxQuery} */\n    let pageList = null;\n    // Create an observer instance to watch for child add/remove\n    const domObserver = new MutationObserver(function(a, b) {\n        // TODO: this does not seem to be working, fix it! =/\n        // update child list and re-layout\n        pageList = cp.view().children();\n        updateLayout();\n    });\n\n    cp.init = function() {\n        let options = cp.options();\n        let view = cp.view();\n        options.html = false;\n        options.css = false;\n        enablePaging = (options.enablePaging === true || (view.attr('data-o-paging') === 'true'));\n        enableAutoSlide = (options.autoSlide === true || (view.attr('data-o-slide') === 'true'));\n        holdTouch = (options.holdTouch === true || (view.attr('data-o-hold') === 'true'));\n        if (options.verticalLayout === true || (view.attr('data-o-layout') === LAYOUT_VERTICAL)) {\n            layoutType = LAYOUT_VERTICAL;\n        }\n        if (options.slideInterval != null) {\n            slideIntervalMs = options.slideInterval;\n        } else if (view.attr('data-o-slide-interval') != null) {\n            slideIntervalMs = parseInt(view.attr('data-o-slide-interval'));\n        }\n    };\n\n    cp.create = function() {\n        const view = cp.view();\n        // enable absolute positioning for items in this view\n       view.css({\n            'position': 'relative',\n            'overflow': 'hidden'\n        });\n        // get child items (pages)\n        pageList = view.children();\n        // loading of images could change elements size, so layout update might be required\n        view.find('img').each(function(i, el) {\n            this.one('load', updateLayout);\n        });\n        // re-arrange view on layout changes\n        zuix.$(window).on('orientationchange', function() {\n            updateLayout();\n        });\n        // Options for the observer (which mutations to observe)\n        const config = {attributes: false, childList: true, subtree: false};\n        // Register DOM mutation observer callback\n        domObserver.observe(view.get(), config);\n        updateLayout();\n        // Set starting page\n        setPage(0);\n        let tapTimeout = null;\n        // gestures handling - load gesture_helper controller\n        zuix.load('@lib/controllers/gesture_helper', {\n            view: view,\n            on: {\n                'gesture:touch': function(e, tp) {\n                    inputCaptured = false;\n                    stopAutoSlide();\n                    dragStart();\n                    if (holdTouch) tp.cancel();\n                },\n                'gesture:release': function(e, tp) {\n                    dragStop(tp);\n                    resetAutoSlide();\n                },\n                'gesture:tap': function(e, tp) {\n                    if (tapTimeout != null) {\n                        clearTimeout(tapTimeout);\n                    }\n                    tapTimeout = setTimeout(function() {\n                        handleTap(e, tp);\n                    }, 50);\n                },\n                'gesture:pan': handlePan,\n                'gesture:swipe': handleSwipe\n            }\n        });\n        // public component methods\n        cp.expose('page', function(number) {\n            if (number == null) {\n                return parseInt(currentPage);\n            } else setPage(number, DEFAULT_PAGE_TRANSITION);\n        }).expose('get', function(number) {\n            return pageList.eq(number);\n        }).expose('slide', function(activate) {\n            if (activate === true) {\n                resetAutoSlide();\n            } else stopAutoSlide();\n        }).expose('layout', function(mode) {\n            if (mode == null) {\n                return layoutType;\n            } else if (mode === LAYOUT_VERTICAL) {\n                layoutType = LAYOUT_VERTICAL;\n            } else layoutType = LAYOUT_HORIZONTAL;\n            updateLayout();\n        }).expose('refresh', function() {\n            updateLayout();\n        }).expose('next', next)\n            .expose('prev', prev)\n            .expose('last', last)\n            .expose('first', first);\n    };\n\n    cp.destroy = function() {\n        if (domObserver != null) {\n            domObserver.disconnect();\n        }\n    };\n\n    function updateLayout() {\n        if (updateLayoutTimeout != null) {\n            clearTimeout(updateLayoutTimeout);\n        }\n        updateLayoutTimeout = setTimeout(layoutElements, 250);\n    }\n    function layoutElements() {\n        if (isDragging || componentizeInterval != null) {\n            updateLayout();\n            return;\n        }\n        // init elements\n        pageList.each(function(i, el) {\n            this.css({\n                'position': 'absolute',\n                'left': 0,\n                'top': 0\n            });\n        });\n        // measure\n        const viewSize = getSize(cp.view().get());\n        if (viewSize.width === 0 || viewSize.height === 0) {\n            // cannot measure view, try again later\n            updateLayout();\n            return;\n        }\n        // position elements\n        let offset = 0;\n        pageList.each(function(i, el) {\n            let size = getSize(el);\n            if (layoutType === LAYOUT_HORIZONTAL) {\n                transition(this, DEFAULT_PAGE_TRANSITION);\n                position(this, offset, 0);\n                offset += size.width;\n            } else {\n                transition(this, DEFAULT_PAGE_TRANSITION);\n                position(this, 0, offset);\n                offset += size.height;\n            }\n        });\n        // focus to current page\n        setPage(currentPage);\n        // start automatic slide\n        if (pageList.length() > 1) {\n            resetAutoSlide();\n        }\n    }\n\n    function next() {\n        let isLast = false;\n        let page = parseInt(currentPage)+1;\n        if (page >= pageList.length()) {\n            page = pageList.length()-1;\n            isLast = true;\n        }\n        setPage(page, DEFAULT_PAGE_TRANSITION);\n        return !isLast;\n    }\n    function prev() {\n        let isFirst = false;\n        let page = parseInt(currentPage)-1;\n        if (page < 0) {\n            page = 0;\n            isFirst = true;\n        }\n        setPage(page, DEFAULT_PAGE_TRANSITION);\n        return !isFirst;\n    }\n    function first() {\n        setPage(0, DEFAULT_PAGE_TRANSITION);\n    }\n    function last() {\n        setPage(pageList.length()-1, DEFAULT_PAGE_TRANSITION);\n    }\n\n    function slideNext() {\n        setPage(parseInt(currentPage) + slideDirection, DEFAULT_PAGE_TRANSITION);\n        resetAutoSlide();\n    }\n\n    function resetAutoSlide(timeout) {\n        stopAutoSlide();\n        if (enableAutoSlide === true) {\n            const visible = cp.view().position().visible;\n            if (visible) {\n                if (!wasVisible) {\n                    zuix.componentize(cp.view());\n                }\n                slideTimeout = setTimeout(slideNext, slideIntervalMs);\n            } else {\n                slideTimeout = setTimeout(resetAutoSlide, 500);\n            }\n            wasVisible = visible;\n        }\n    }\n    function stopAutoSlide() {\n        if (slideTimeout != null) {\n            clearTimeout(slideTimeout);\n        }\n    }\n\n    function getItemIndexAt(x, y) {\n        let focusedPage = 0;\n        pageList.each(function(i, el) {\n            let data = getData(this);\n            focusedPage = i;\n            const size = getSize(el);\n            const rect = {\n                x: data.position.x,\n                y: data.position.y,\n                w: size.width,\n                h: size.height\n            };\n            if ((layoutType === LAYOUT_HORIZONTAL && (rect.x > x || rect.x+rect.w > x))\n                || (layoutType === LAYOUT_VERTICAL && (rect.y > y || rect.y+rect.h > y))) {\n                return false;\n            }\n        });\n        return focusedPage;\n    }\n\n    function focusPageAt(tp, transition) {\n        let vp = cp.view().position();\n        let page = getItemIndexAt(tp.x-vp.x, tp.y-vp.y);\n        setPage(page, transition != null ? transition : DEFAULT_PAGE_TRANSITION);\n    }\n\n    function setPage(n, transition) {\n        oldPage = currentPage;\n        if (n < 0) {\n            slideDirection = SLIDE_DIRECTION_FORWARD;\n            n = 0;\n        } else if (n >= pageList.length()) {\n            slideDirection = SLIDE_DIRECTION_BACKWARD;\n            n = pageList.length() - 1;\n        } else if (n !== currentPage) {\n            slideDirection = (currentPage < n) ? SLIDE_DIRECTION_FORWARD : SLIDE_DIRECTION_BACKWARD;\n        }\n        currentPage = n;\n        if (currentPage != oldPage) {\n            pageList.eq(currentPage).css('z-index', 1);\n            if (oldPage !== -1) {\n                pageList.eq(oldPage).css('z-index', 0);\n            }\n            cp.trigger('page:change', {in: currentPage, out: oldPage});\n        }\n        const el = pageList.eq(n);\n        const data = getData(el);\n        const elSize = getSize(el.get());\n        const viewSize = getSize(cp.view().get());\n        const focusPoint = {\n            x: (viewSize.width - elSize.width) / 2 - data.position.x,\n            y: (viewSize.height - elSize.height) / 2 - data.position.y\n        };\n        flyTo(focusPoint, transition);\n        resetAutoSlide();\n    }\n\n    function flyTo(targetPoint, transition) {\n        const viewSize = getSize(cp.view().get());\n        const spec = getFrameSpec();\n        const firstData = getData(pageList.eq(0));\n        const lastPage = pageList.eq(pageList.length() - 1);\n        const lastData = getData(lastPage);\n\n        pageList.each(function(i, el) {\n            const data = getData(this);\n            const frameSpec = getFrameSpec();\n            data.dragStart = {\n                x: frameSpec.marginLeft + data.position.x,\n                y: frameSpec.marginTop + data.position.y\n            };\n        });\n\n        if (layoutType === LAYOUT_HORIZONTAL) {\n            let x = targetPoint.x;\n            if (firstData.position.x + targetPoint.x > 0) {\n                x = -firstData.position.x;\n            } else {\n                if (lastData.position.x + lastPage.get().offsetWidth + targetPoint.x < viewSize.width) {\n                    x = -spec.marginLeft*2 + viewSize.width - (lastData.position.x + lastPage.get().offsetWidth);\n                }\n            }\n            if (targetPoint.x-x !== 0 && transition != null) {\n                transition = {\n                    duration: transition.duration,\n                    easing: transition.easing\n                };\n                transition.duration *= (x / targetPoint.x);\n                if (transition.duration < 0) transition.duration = 0.15;\n            }\n            dragShift(x, 0, transition);\n        } else {\n            let y = targetPoint.y;\n            if (firstData.position.y + targetPoint.y > 0) {\n                y = -firstData.position.y;\n            } else {\n                if (lastData.position.y + lastPage.get().offsetHeight + targetPoint.y < viewSize.height) {\n                    y = -spec.marginTop*2 + viewSize.height - (lastData.position.y + lastPage.get().offsetHeight);\n                }\n            }\n            if (targetPoint.y-y !== 0 && transition != null) {\n                transition = {\n                    duration: transition.duration,\n                    easing: transition.easing\n                };\n                transition.duration *= (y / targetPoint.y);\n                if (transition.duration < 0) transition.duration = 0.15;\n            }\n            dragShift(0, y, transition);\n        }\n    }\n\n    function getSize(el) {\n        const rect = el.getBoundingClientRect();\n        const width = rect.width || el.offsetWidth;\n        const height = el.offsetHeight || rect.height;\n        return {width: width, height: height};\n    }\n\n    function getData(el) {\n        const data = el.get().data = el.get().data || {};\n        data.position = data.position || {x: 0, y: 0};\n        return data;\n    }\n\n    function componentizeStart() {\n        if (isLazyContainer()) {\n            componentizeStop();\n            if (componentizeTimeout != null) {\n                clearTimeout(componentizeTimeout);\n            }\n            if (componentizeInterval != null) {\n                clearInterval(componentizeInterval);\n            }\n            componentizeInterval = setInterval(function() {\n                const viewSize = getSize(cp.view().get());\n                pageList.each(function(i, el) {\n                    // hide elements if not inside the view_pager\n                    const computed = window.getComputedStyle(el, null);\n                    const size = {\n                        width: parseFloat(computed.width.replace('px', '')),\n                        height: parseFloat(computed.height.replace('px', ''))\n                    };\n                    const x = parseFloat(computed.left.replace('px', ''));\n                    const y = parseFloat(computed.top.replace('px', ''));\n                    if (size.width > 0 && size.height > 0) {\n                        el = zuix.$(el);\n                        // check if element is inside the view_pager\n                        if (x + size.width < 0 || y + size.height < 0 || x > viewSize.width || y > viewSize.height) {\n                            if (el.visibility() !== 'hidden') {\n                                el.visibility('hidden');\n                            }\n                        } else if (el.visibility() !== 'visible') {\n                            el.visibility('visible');\n                        }\n                    }\n                });\n                zuix.componentize(cp.view());\n            }, 50);\n        }\n    }\n\n    function componentizeStop() {\n        if (isLazyContainer() && componentizeTimeout == null) {\n            clearInterval(componentizeInterval);\n        }\n    }\n\n    function dragStart() {\n        isDragging = true;\n        componentizeStart();\n        pageList.each(function(i, el) {\n            const data = getData(this);\n            const frameSpec = getFrameSpec();\n            const computed = window.getComputedStyle(el, null);\n            data.position.x = parseFloat(computed.left.replace('px', ''));\n            data.position.y = parseFloat(computed.top.replace('px', ''));\n            this.css('left', data.position.x+'px');\n            this.css('top', data.position.y+'px');\n            data.dragStart = {x: frameSpec.marginLeft+data.position.x, y: frameSpec.marginTop+data.position.y};\n        });\n    }\n\n    function getFrameSpec() {\n        const spec = {\n            w: 0,\n            h: 0,\n            marginLeft: 0,\n            marginTop: 0\n        };\n        const viewSize = getSize(cp.view().get());\n        pageList.each(function(i, el) {\n            const size = getSize(el);\n            spec.w += size.width;\n            spec.h += size.height;\n        });\n        if (layoutType === LAYOUT_HORIZONTAL && spec.w < viewSize.width) {\n            spec.marginLeft = (viewSize.width - spec.w) / 2;\n        } else if (layoutType === LAYOUT_VERTICAL && spec.h < viewSize.height) {\n            spec.marginTop = (viewSize.height - spec.h) / 2;\n        }\n        return spec;\n    }\n\n    function dragShift(x, y, tr) {\n        if (tr != null) {\n            componentizeStart();\n            componentizeTimeout = setTimeout(function() {\n                componentizeTimeout = null;\n                componentizeStop();\n            }, tr.duration*1000);\n            tr = tr.duration+'s '+tr.easing;\n        } else if (isLazyContainer()) {\n            zuix.componentize(cp.view());\n        }\n        pageList.each(function(i, el) {\n            const data = getData(this);\n            transition(this, tr);\n            position(this, data.dragStart.x+x, data.dragStart.y+y);\n        });\n    }\n\n    function dragStop(tp) {\n        if (enablePaging && componentizeTimeout == null) {\n            setTimeout(function() {\n                setPage(currentPage, DEFAULT_PAGE_TRANSITION);\n            }, 10);\n        }\n        if (tp != null) tp.done = true;\n        componentizeStop();\n        isDragging = false;\n    }\n\n    function isLazyContainer() {\n        const lazy = cp.view().find('[data-ui-lazyload=\"true\"]').length() > 0;\n        return lazy;\n    }\n\n    // Gesture handling\n\n    function handlePan(e, tp) {\n        if (tp.scrollMode === 0 || tp.done) {\n            return;\n        }\n        if (inputCaptured\n            || ((tp.direction === 'left' || tp.direction === 'right') && layoutType === LAYOUT_HORIZONTAL)\n            || ((tp.direction === 'up' || tp.direction === 'down') && layoutType === LAYOUT_VERTICAL)) {\n            // capture click event\n            if (!inputCaptured && tp.event.touches == null) {\n                cp.view().get().addEventListener('click', function(e) {\n                    if (inputCaptured) {\n                        inputCaptured = false;\n                        e.preventDefault();\n                        e.cancelBubble = true;\n                    }\n                    // release mouse click capture\n                    cp.view().get().removeEventListener('click', this, true);\n                }, true);\n            }\n            inputCaptured = true;\n            tp.cancel();\n        }\n        const spec = getFrameSpec();\n        if (layoutType === LAYOUT_HORIZONTAL && tp.scrollMode === 1) {\n            dragShift(tp.shiftX-spec.marginLeft, 0);\n        } else if (layoutType === LAYOUT_VERTICAL && tp.scrollMode === 2) {\n            dragShift(0, tp.shiftY-spec.marginTop);\n        }\n    }\n\n    function handleTap(e, tp) {\n        let vp = cp.view().position();\n        let page = getItemIndexAt(tp.x-vp.x, tp.y-vp.y);\n        cp.trigger('page:tap', page, tp);\n        if (enablePaging) focusPageAt(tp);\n    }\n\n    function handleSwipe(e, tp) {\n        const decelerateEasing = {\n            duration: (1+(1/Math.abs(tp.velocity))),\n            easing: 'cubic-bezier(0.1,0.45,0.35,1.1)'\n        };\n        const fly = function(destination, shift) {\n            if (enablePaging) {\n                if (layoutType === LAYOUT_HORIZONTAL) {\n                    focusPageAt({\n                        x: destination.x - shift.x,\n                        y: destination.y\n                    }, decelerateEasing);\n                } else {\n                    focusPageAt({\n                        x: destination.x,\n                        y: destination.y - shift.y\n                    }, decelerateEasing);\n                }\n            } else {\n                flyTo(shift, decelerateEasing);\n            }\n        };\n        const fastSwipe = (!enablePaging && Math.abs(tp.velocity) > 0.35) || (Math.abs(tp.velocity) > 1.25);\n        const ap = {\n            x: (tp.velocity * 1000),\n            y: (tp.velocity * 1000)\n        };\n        switch (tp.direction) {\n            case 'right':\n                if (layoutType === LAYOUT_HORIZONTAL) {\n                    if (fastSwipe) fly(tp, ap);\n                    else if (enablePaging) prev();\n                }\n                break;\n            case 'left':\n                if (layoutType === LAYOUT_HORIZONTAL) {\n                    if (fastSwipe) fly(tp, ap);\n                    else if (enablePaging) next();\n                }\n                break;\n            case 'down':\n                if (layoutType === LAYOUT_VERTICAL) {\n                    if (fastSwipe) fly(tp, ap);\n                    else if (enablePaging) prev();\n                }\n                break;\n            case 'up':\n                if (layoutType === LAYOUT_VERTICAL) {\n                    if (fastSwipe) fly(tp, ap);\n                    else if (enablePaging) next();\n                }\n                break;\n        }\n    }\n\n    function position(el, x, y) {\n        const data = getData(el);\n        if (!isNaN(x) && !isNaN(y)) {\n            data.position = {'x': x, 'y': y};\n            el.css({'left': data.position.x+'px', 'top': data.position.y+'px'});\n        }\n        return data;\n    }\n\n    function transition(el, transition) {\n        if (transition == null) {\n            transition = 'none';\n        }\n        el.css({\n            '-webkit-transition': transition,\n            '-moz-transition': transition,\n            '-ms-transition': transition,\n            '-o-transition': transition,\n            'transition': transition\n        });\n    }\n});\n"
  },
  {
    "componentId": "@lib/components/menu_overlay",
    "controller": "'use strict';\n\nzuix.controller(function(cp) {\n    let menuOverlayShowing = false;\n    let menuButtonShowing = true;\n    let menuButton;\n    let menuButtonClose;\n    let menuOverlay;\n    let itemsWrapper;\n    let menuItems;\n    let scroller = null;\n    let currentOffset = 0;\n\n    cp.create = function() {\n        menuButton = cp.field('menu_button').hide()\n            .on('click', toggleMenu);\n        menuButtonClose = cp.field('menu_button_close').hide()\n            .on('click', toggleMenu);\n        menuOverlay = cp.field('menu_overlay').visibility('hidden')\n            .on('click', toggleMenu);\n        itemsWrapper = cp.field('items_wrapper');\n\n        const items = zuix.$(cp.model().items).children();\n        items.each(function(i, el) {\n            const wrapperDiv = zuix.$(document.createElement('div'))\n                .addClass('menu-item')\n                .attr('data-ui-transition-delay', (.3/(items.length()-i))+'s')\n                .append(el);\n            itemsWrapper.append(wrapperDiv.get());\n        });\n        menuItems = itemsWrapper.find('div[class*=\"menu-item\"]');\n\n        // apply custom color to menu button\n        if (cp.view().attr('data-o-button-color') != null) {\n            cp.view().find('.circle-button').css('background', cp.view().attr('data-o-button-color'));\n        }\n        if (cp.view().attr('data-o-icon-color') != null) {\n            cp.view().find('.circle-button').css('fill', cp.view().attr('data-o-icon-color'));\n        }\n\n        const scrollerName = cp.view().attr('data-o-scroller');\n        if (scrollerName != null) {\n            scroller = zuix.field(scrollerName);\n        } else {\n            scroller = zuix.$(window);\n        }\n        if (scroller != null) {\n            scroller.on('scroll', function(e) {\n                const scrollTop = scroller.get() === window ? (document.documentElement.scrollTop || document.body.scrollTop) : scroller.get().scrollTop;\n                if (menuButtonShowing) {\n                    if ((currentOffset - scrollTop) < -2) hideButton();\n                } else if (!menuButtonShowing) {\n                    if ((currentOffset - scrollTop) > 2) showButton();\n                }\n                currentOffset = scrollTop;\n                if (menuOverlayShowing) {\n                    toggleMenu();\n                }\n            });\n        }\n\n        // Animate CSS extension\n        zuix.using('component', '@lib/extensions/animate_css', function(res, ctx) {\n            // show floating action button\n            setTimeout(function() {\n                menuButton.animateCss('slideInUp').show();\n            }, 1000);\n        });\n        // Material Design Light integration - DOM upgrade\n        if (typeof componentHandler !== 'undefined') {\n            componentHandler.upgradeElements(cp.view().get());\n        }\n\n        cp.expose('show', function() {\n            cp.view().show();\n        });\n        cp.expose('hide', function() {\n            cp.view().hide();\n        });\n        cp.expose('toggleButton', toggleButton);\n        cp.expose('showButton', showButton);\n        cp.expose('hideButton', hideButton);\n    };\n\n    function toggleButton() {\n        if (menuButtonShowing) {\n            hideButton();\n        } else {\n            showButton();\n        }\n    }\n\n    function hideButton() {\n        menuButtonShowing = false;\n        menuButton.animateCss('fadeOutDown', {duration: '0.3s'}, function() {\n            this.hide();\n        });\n        cp.trigger('hide');\n    }\n\n    function showButton() {\n        menuButtonShowing = true;\n        menuButton.animateCss('fadeInUp').show();\n        cp.trigger('show');\n    }\n\n    function toggleMenu() {\n        if (!menuOverlayShowing) {\n            menuOverlayShowing = true;\n            cp.trigger('open');\n            menuButton.animateCss('rotateOut', {duration: '0.3s'});\n            menuButtonClose.animateCss('rotateIn', {duration: '0.3s'}, function() {\n                menuButton.hide();\n            }).show();\n            menuOverlay.animateCss('fadeIn', {duration: '0.5s'}).visibility('');\n            menuItems.each(function(p, el) {\n                let transitionDelay = '0';\n                if (this.attr('data-ui-transition-delay') != null) {\n                    transitionDelay = this.attr('data-ui-transition-delay');\n                }\n                this.animateCss('bounceInRight', {duration: '0.5s', delay: transitionDelay});\n            });\n        } else if (menuOverlayShowing) {\n            menuOverlayShowing = false;\n            cp.trigger('close');\n            if (menuButtonShowing) {\n                menuButtonClose.animateCss('rotateOut', {duration: '0.3s'}, function() {\n                    this.hide();\n                });\n                menuButton.animateCss('rotateIn', {duration: '0.3s'});\n            } else {\n                menuButtonClose.animateCss('fadeOutDown', {duration: '0.3s'}, function() {\n                    this.hide();\n                });\n            }\n            menuOverlay.animateCss('fadeOut', {duration: '0.5s', delay: '0.2s'}, function() {\n                this.visibility('hidden');\n            });\n            menuItems.each(function(p, el) {\n                let transitionDelay = '0';\n                if (this.attr('data-ui-transition-delay') != null) {\n                    transitionDelay = this.attr('data-ui-transition-delay');\n                }\n                this.animateCss('fadeOutRight', {duration: '0.5s', delay: transitionDelay});\n            });\n            menuButton.show();\n        }\n    }\n});\n",
    "css": ".menu-button {\n    z-index: 100; /* topmost */\n    position: fixed;\n    right: 32px;\n    bottom: 32px;\n}\ndiv[data-ui-field=\"menu_overlay\"] {\n    z-index: 100; /* topmost */\n    position: fixed;\n    left: 0;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    padding-top: 80px;\n    padding-bottom: 96px;\n    padding-left: 32px;\n    background-color: rgba(255, 255, 255, 0.85);\n    display: flex;\n    justify-content: space-between;\n    flex-direction: column-reverse;\n}\ndiv[data-ui-field=\"items_wrapper\"] {\n    text-align: right;\n    margin-top: auto;\n}\n\n.menu-item {\n    padding-top: 8px;\n    padding-bottom: 8px;\n    margin-right: 32px;\n}\n\n.circle-button {\n    border-radius: 50%;\n    width: 56px;\n    height: 56px;\n    margin: 4px;\n    background: deeppink;\n    fill: white;\n    box-shadow: 0 4px 8px rgba(0,0,0,0.25), 0 2px 4px rgba(0,0,0,0.5);\n    vertical-align: middle;\n    text-align: center;\n    font-size: 0;\n    display: table-cell;\n    transition: all 0.3s cubic-bezier(.25,.8,.25,1);\n}\n\n@media only screen and (max-width: 640px) {\n    .menu-button {\n        right: 16px;\n        bottom: 16px;\n    }\n    .menu-item {\n        margin-right: 16px;\n    }\n    div[data-ui-field=\"menu_overlay\"] {\n        padding-bottom: 72px;\n    }\n}"
  },
  {
    "componentId": "@lib/controllers/gesture_helper",
    "controller": "/**\n * zUIx - Gesture Controller\n *\n * @version 1.0.0 (2018-03-11)\n * @author Gene\n *\n */\n\n'use strict';\n\nzuix.controller(function(cp) {\n    const SCROLL_MODE_NONE = 0;\n    const SCROLL_MODE_HORIZONTAL = 1;\n    const SCROLL_MODE_VERTICAL = 2;\n    const GESTURE_TAPTIMEOUT = 750;\n\n    let scrollMode = SCROLL_MODE_NONE;\n    let touchPointer = null;\n    let ignoreSession = false;\n    let currentGesture = null;\n    let swipeDirection = null;\n    let mouseButtonDown = false;\n    let lastTapTime = new Date().getTime();\n\n    // Math.sign Polyfill\n    Math.sign = Math.sign || function(x) {\n        return ((x>0)-(x<0))||+x;\n    };\n\n    cp.init = function() {\n        cp.options().html = false;\n        cp.options().css = false;\n    };\n\n    cp.create = function() {\n        // TODO: should use event \"capturing\" instead of \"bubbling\"\n        cp.view().on('dragstart', function(e) {\n            if (!ignoreSession) {\n                e.preventDefault();\n            }\n        }).on('mousedown', function(e) {\n            const targetElement = zuix.$(e.target);\n            if (e.which === 1 && targetElement.parent('[class*=\"no-gesture\"]').length() === 0) {\n                mouseButtonDown = true;\n                ignoreSession = false;\n                touchStart(e, e.x, e.y);\n            } else ignoreSession = true;\n        }).on('mousemove', function(e) {\n            if (!ignoreSession && mouseButtonDown) {\n                touchMove(e, e.x, e.y);\n            }\n        }).on('mouseup', function(e) {\n            if (e.which === 1 && !ignoreSession) {\n                mouseButtonDown = false;\n                touchStop(e);\n            }\n        }).on('touchstart', function(e) {\n            const targetElement = zuix.$(e.target);\n            if (targetElement.parent('[class*=\"no-gesture\"]').length() === 0) {\n                ignoreSession = false;\n                touchStart(e, e.touches[0].clientX, e.touches[0].clientY);\n            } else ignoreSession = true;\n        }).on('touchmove', function(e) {\n            if (!ignoreSession) {\n                touchMove(e, e.touches[0].clientX, e.touches[0].clientY);\n            }\n        }).on('touchend', function(e) {\n            if (!ignoreSession) {\n                touchStop(e);\n            }\n        });\n    };\n\n    function touchStart(e, x, y) {\n        let timestamp = new Date().getTime();\n        touchPointer = {\n            // original event + cancel method\n            event: e,\n            cancel: function() {\n                touchPointer.event.cancelBubble = true;\n                touchPointer.event.preventDefault();\n            },\n            // initial touch position\n            startX: x,\n            startY: y,\n            startTime: timestamp,\n            // relative movement\n            shiftX: 0,\n            shiftY: 0,\n            endTime: 0,\n            // relative movement at every step\n            stepX: 0,\n            stepY: 0,\n            stepTime: timestamp,\n            // actual position and speed\n            velocity: 0,\n            x: x,\n            y: y\n        };\n        cp.trigger('gesture:touch', touchPointer);\n    }\n    function touchMove(e, x, y) {\n        if (touchPointer != null) {\n            touchPointer.event = e;\n            touchPointer.x = x;\n            touchPointer.y = y;\n            touchPointer.shiftX = (x - touchPointer.startX);\n            touchPointer.shiftY = (y - touchPointer.startY);\n            touchPointer.endTime = new Date().getTime();\n            // detect actual gesture\n            let gesture = detectGesture();\n            if (gesture != null && currentGesture !== false) {\n                if (swipeDirection != null && swipeDirection !== touchPointer.direction) {\n                    // stop gesture detection if not coherent\n                    currentGesture = false;\n                    swipeDirection = touchPointer.direction = 'cancel';\n                } else {\n                    currentGesture = gesture;\n                    swipeDirection = touchPointer.direction;\n                }\n            }\n            cp.trigger('gesture:pan', touchPointer);\n        }\n    }\n\n    function touchStop(e) {\n        if (touchPointer != null) {\n            touchPointer.event = e;\n            if (currentGesture == null) {\n                currentGesture = detectGesture();\n            }\n            if (currentGesture != null && currentGesture !== false) {\n                cp.trigger(currentGesture, touchPointer);\n            }\n        }\n        cp.trigger('gesture:release', touchPointer);\n        scrollMode = SCROLL_MODE_NONE;\n        swipeDirection = null;\n        currentGesture = null;\n        touchPointer = null;\n    }\n\n    function detectGesture() {\n        let gesture = null;\n        const elapsedTime = touchPointer.endTime-touchPointer.stepTime;\n        const l = {x: (touchPointer.shiftX-touchPointer.stepX), y: (touchPointer.shiftY-touchPointer.stepY)};\n        const d = Math.sqrt(l.x*l.x+l.y*l.y);\n        touchPointer.velocity = (d/elapsedTime);\n        const minDistance = 3;\n        const angle = Math.atan2(touchPointer.shiftY-touchPointer.stepY, touchPointer.shiftX-touchPointer.stepX) * 180 / Math.PI;\n        if ((touchPointer.shiftX) === 0 && (touchPointer.shiftY) === 0 && touchPointer.startTime > lastTapTime+100 && elapsedTime < GESTURE_TAPTIMEOUT) {\n            // gesture TAP\n            lastTapTime = new Date().getTime();\n            gesture = 'gesture:tap';\n        } else if ((scrollMode === SCROLL_MODE_NONE || scrollMode === SCROLL_MODE_HORIZONTAL)\n            && d > minDistance && ((angle >= 135 && angle <= 180) || (angle >= -180 && angle <= -135))) {\n            // gesture swipe RIGHT\n            touchPointer.direction = 'left';\n            touchPointer.velocity *= -1;\n            gesture = 'gesture:swipe';\n            scrollMode = SCROLL_MODE_HORIZONTAL;\n        } else if ((scrollMode === SCROLL_MODE_NONE || scrollMode === SCROLL_MODE_HORIZONTAL)\n            && d > minDistance && ((angle >= 0 && angle <= 45) || (angle >= -45 && angle < 0))) {\n            // gesture swipe LEFT\n            touchPointer.direction = 'right';\n            gesture = 'gesture:swipe';\n            scrollMode = SCROLL_MODE_HORIZONTAL;\n        } else if ((scrollMode === SCROLL_MODE_NONE || scrollMode === SCROLL_MODE_VERTICAL)\n            && d > minDistance && (angle > 45 && angle < 135)) {\n            // gesture swipe UP\n            touchPointer.direction = 'down';\n            gesture = 'gesture:swipe';\n            scrollMode = SCROLL_MODE_VERTICAL;\n        } else if ((scrollMode === SCROLL_MODE_NONE || scrollMode === SCROLL_MODE_VERTICAL)\n            && d > minDistance && (angle > -135 && angle < -45)) {\n            // gesture swipe DOWN\n            touchPointer.direction = 'up';\n            touchPointer.velocity *= -1;\n            gesture = 'gesture:swipe';\n            scrollMode = SCROLL_MODE_VERTICAL;\n        }\n        touchPointer.scrollMode = scrollMode;\n        // reset touch step data\n        if (d > minDistance) {\n            touchPointer.stepTime = touchPointer.endTime;\n            touchPointer.stepX = touchPointer.shiftX;\n            touchPointer.stepY = touchPointer.shiftY;\n        }\n        return gesture;\n    }\n});\n"
  }
])</script>
</body></html>